<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Software for Robots]]></title><description><![CDATA[Real-Time Control, Networking, Operating Systems, Languages]]></description><link>https://ennerf.github.io</link><image><url>https://raw.githubusercontent.com/ennerf/ennerf.github.io/master/images/cover-image.jpg</url><title>Software for Robots</title><link>https://ennerf.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Sun, 28 Aug 2016 03:38:15 GMT</lastBuildDate><atom:link href="https://ennerf.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Latency : Operating Systems]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Latency is an important topic for many applications that is unfortunately often misunderstood. I&#8217;ve spent many hours looking for information on the latency of various components, but have found very little informative data out there. Most benchmarks focus on the maximum throughput and either completely neglect latency, or measure it incorrectly.</p>
</div>
<div class="paragraph">
<p>My own background is in robotics research. I&#8217;ve spent several years as a staff software engineer at the Robotics Institute at Carnegie Mellon University and am a co-founder of HEBI Robotics, a startup developing modular robotic components. We&#8217;ve worked on many different types of robots, including collaborative arms, wheeled robots, walking robots and snake robots.</p>
</div>
<div class="paragraph">
<p>Robots are controlled in <em>real-time</em>, which means that a command gets executed within a <em>deadline</em> (fixed period of time). There are <em>hard real-time</em> systems that must never exceed their deadline, and <em>soft real-time</em> systems that are able to occasionally handle reasonable outliers. Missing deadlines can result in unwanted motions and 'jerky' behavior.</p>
</div>
<div class="paragraph">
<p>Although there is a lot of information on the theoretical definition of these terms, it can be challenging to determine good deadlines for practical applications. This is especially true for research environments that build unique mechanisms.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the control scheme is a systemic concern that can impact the entire system architecture. This can be very difficult to change later on, so there is a tendency towards high requirements with regards to determinism. However, requirements that are too high can result in significant development efforts that may not yield any benefits in the real world.</p>
</div>
<div class="paragraph">
<p>Over a series of blog posts, I&#8217;ll try to share some my own experiences and data sets. Today&#8217;s post will focus on operating systems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operating_systems">Operating Systems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The operating system is the base of everything. No matter how amazing the software stack is, the system is fundamentally bound by the capabilities of the OS, it&#8217;s scheduler, and the overall load on the system. Before you start optimizing your own software, you should make sure that your goal is actually achievable on the underlying platform.</p>
</div>
<div class="paragraph">
<p>There is a trade-off between responding in a timely manner and overall performance, battery life, and many other concerns. As a result, the major consumer operating systems don&#8217;t guarantee to meet hard deadlines and can theoretically have arbitrarily long pauses.</p>
</div>
<div class="paragraph">
<p>However, commodity operating systems can significantly ease development. It is worth evaluating their actual performance before prematurely dismissing them for real-time control systems. Even though there may not be any theoretical guarantees, the practical differences are often not noticeable.</p>
</div>
<div class="sect2">
<h3 id="_measuring_latency">Measuring Latency</h3>
<div class="paragraph">
<p>The first important realization when looking at latency is that data does not follow a Gaussian distribution. I have seen many data sets where the worst observed case was more than 1000 standard deviations away from the mean. Looking at only the mean and standard deviation tends to provide an extremely optimistic view that can be misleading.</p>
</div>
<div class="paragraph">
<p>A better way to look at latency is via histograms and percentile plots, e.g., "<em>99.9% of measurements were below X ms</em>". There are already several good resources about recording latency out there, so I won&#8217;t go into detail. Please refer to <a href="http://psy-lob-saw.blogspot.com/2015/02/hdrhistogram-better-latency-capture.html">HdrHistogram: A better latency capture method</a> or <a href="https://youtu.be/lJ8ydIuPFeU">How NOT to Measure Latency</a> for more information.</p>
</div>
<div class="paragraph">
<p><a href="https://www.azul.com">Azul Systems</a> sells products targeted at latency sensitive applications and they have created a variety of useful tools to measure latency. <a href="https://github.com/giltene/jHiccup">jHiccup</a> is a tool that allows us to measure and record system level 'hiccups'. It measures the time for <em>sleep(1ms)</em> and records the delta to the fastest previously recorded sample. For example, if the fastest sample was 1ms, but it took 3ms to wake up, it will record a 2ms hiccup. Hiccups can be caused by a large number of reasons, including scheduling, paging, indexing, and many more. By running it on an idle system, we can measure the best case scenario. jHiccup uses <a href="https://github.com/HdrHistogram/HdrHistogram">HdrHistogram</a> for the recording of samples. It can be started with the following command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre># record logs each second for 48 hours
intervalMs=1000
runtimeMs=172800000
java -javaagent:jHiccup.jar="-d 0 -i ${intervalMs}" -cp jHiccup.jar org.jhiccup.Idle -t ${runtimeMs}</pre>
</div>
</div>
<div class="paragraph">
<p>Lastly, I&#8217;m using <a href="https://github.com/ennerf/HdrHistogramVisualizer">HdrHistogramVisualizer</a> which is a tool that I&#8217;ve written for visualizing the recorded data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_benchmark_setup">Benchmark Setup</h3>
<div class="paragraph">
<p>I&#8217;ve setup two standard desktop computers, one for Windows/Linux and one for Mac tests.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gigabyte Brix BXi7-4770R, i7-4770R @ 3.2 GHz, 16 GB 1600 MHz DDR3</p>
</li>
<li>
<p>Mac Mini 2014, i7-3720QM @ 2.6 GHz, 16 GB 1600 MHz DDR3</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When doing latency tests on Windows you should be aware of the system timer. It has variable timer intervals that range from 0.5ms to 15.6ms. By calling <em>timeBeginPeriod</em> and <em>endTimePeriod</em> applications can notify the OS whenever they need a higher resolution. The timer interrupt is a global resource that gets set to the lowest interrupt interval requested by any application. For example, watching a video in Chrome requests a timer interrupt interval of 0.5ms. A lower period results in a more responsive system at the cost of overall throughput and battery life. <a href="https://vvvv.org/contribution/windows-system-timer-tool">System Timer Tool</a> is a little utility that let&#8217;s you view the current state. Calling Java&#8217;s <em>Thread.sleep()</em> with a value of below 10ms automatically requests a 1ms timer interval.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TODO: Confirm that system timer was set to 1ms for test.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_windows_mac_linux">Windows / Mac / Linux</h3>
<div class="paragraph">
<p>Let&#8217;s first look at the performance of consumer operating systems: Windows, Mac and Linux. Each test started off with a clean install for each OS. The only two modifications to the stock installation were to disable sleep mode and to install JDK8 (update 101) to run jHiccup. I then started the test, unplugged all external cables and let the computer sit 'idle' for &gt;24 hours. The actual OS versions were,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Windows 10 Enterprise, version 1511 (OS build: 10586.545)</p>
</li>
<li>
<p>OS X, version 10.9.5</p>
</li>
<li>
<p>Ubuntu 16.04 Desktop, kernel 4.4.0-31-generic</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each image below contains two charts. The top section shows the worst hiccup that occured within a given interval window, i.e., the first data point shows the worst hiccup within the first 3 minutes and the next data point shows the worst hiccup within the next 3 minutes. The bottom chart shows the percentiles of all measurements across the entire duration. Each 24 hour data set contains roughly 70-80 million samples.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="/images/os/osx-win-ubuntu_24h.png"><img src="https://ennerf.github.io/images/os/osx-win-ubuntu_24h.png" alt="osx windows ubuntu latency over 24 hours"></a>
</div>
</div>
<div class="paragraph">
<p>Up to the 90th percentile all three systems respond relatively similarly, but there are significant differences at the higher percentiles. There also seems to have been a period of increased system activity on OSX after 7 hours. The chart below shows a zoomed in view of a 10 minute time period starting at 10 hours.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="/images/os/osx-win-ubuntu_10m.png"><img src="https://ennerf.github.io/images/os/osx-win-ubuntu_10m.png" alt="osx windows ubuntu latency over 10 minutes"></a>
</div>
</div>
<div class="paragraph">
<p>Overall Ubuntu 16.04 seems to have very little hiccups compared to Windows and OSX.</p>
</div>
</div>
<div class="sect2">
<h3 id="_real_time_linux">Real Time Linux</h3>
<div class="paragraph">
<p>Now that we have a better understanding of how traditional systems without tuning perform, let&#8217;s take a look at the performance of Linux with a real-time kernel. The rt kernel (PREEMPT_RT patch) can preempt lower priority tasks, which results in worse overall performance, but more deterministic behavior with respect to latency.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve chosen Scientific Linux 6 because of it&#8217;s support for <a href="https://access.redhat.com/products/red-hat-enterprise-mrg-realtime">Red Hat&#174; Enterprise MRG Realtime&#174;</a>. You can download the  <a href="http://ftp.scientificlinux.org/linux/scientific/">ISO</a> and find instructions for installing MRG Realtime <a href="http://linux.web.cern.ch/linux/mrg/">here</a>. The version I&#8217;ve tested was,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scientific Linux 6.6, kernel 3.10.0-327.rt56.194.el6rt.x86_64</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that there is a huge number of tuning options that may improve the performance of your application. There are various tuning guides that can provide more information, e.g., Red Hat&#8217;s <a href="http://linux.web.cern.ch/linux/mrg/2.3/Red_Hat_Enterprise_MRG-2-Realtime_Tuning_Guide-en-US.pdf">MRG Realtime Tuning Guide</a>. I&#8217;m not very familiar with tuning systems at this level, so I&#8217;ve only applied the following small list of changes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>/boot/grub/menu.lst</em> &#8658; <em>transparent_hugepage=never</em></p>
</li>
<li>
<p><em>/etc/sysctl.conf</em> &#8658; <em>vm.swappiness=0</em></p>
</li>
<li>
<p><em>/etc/inittab</em> &#8658; <em>id:3:initdefault</em> (no GUI)</p>
</li>
<li>
<p><em>chkconfig --level 0123456 cpuspeed off</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The process priority was set to 98, which is the highest priority available for real-time threads. I&#8217;d advise consulting
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/2/html/Realtime_Tuning_Guide/chap-Realtime-Specific_Tuning.html#Setting_scheduler_priorities">scheduler priorities</a> before deciding on priorities for tasks that actually use cpu time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># find process id
pid=$(pgrep -f "[j]Hiccup.jar")

# show current priority
echo $(chrt -p $pid)

# set priority
sudo chrt -p 98 $pid</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is a comparison of the two Linux variants. 24 hours with 3 minute intervals,</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="/images/os/ubuntu-scl_24h.png"><img src="https://ennerf.github.io/images/os/ubuntu-scl_24h.png" alt="ubuntu scientific linux latency over 24 hours"></a>
</div>
</div>
<div class="paragraph">
<p>and 10 minutes at 1 second intervals.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="/images/os/ubuntu-scl_10m.png"><img src="https://ennerf.github.io/images/os/ubuntu-scl_10m.png" alt="ubuntu scientific linux latency over 10 minutes"></a>
</div>
</div>
<div class="paragraph">
<p>I&#8217;ve also added the 24 hour chart for only the real-time variant to provide a better scale. Note that this resolution is getting close to what we can measure and record.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="/images/os/scl_24h.png"><img src="https://ennerf.github.io/images/os/scl_24h.png" alt="scientific linux latency over 24 hours"></a>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_final_notes">Final Notes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;ve tried to provide a basic idea of the out of the box performance of various off the shelf operating systems. Actual requirements are heavily dependent on the specific use case, so it&#8217;s impossible to make a general recommendation. While some safety critical applications may require a real time operating system (RTOS), others may run perfectly fine on commodity systems. My goal is to provide an overview that allows you to make a more informed decision about suitable platform after you&#8217;ve established your requirements. I&#8217;m planning on doing a future post on actually figuring out sane requirements.</p>
</div>
<div class="paragraph">
<p>Note that these are not your only options. There are many different <a href="https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems">RTOS</a> out there. There are even real-time extensions for Windows, e.g., <a href="http://www.tenasys.com/overview-ifw">INtime</a> or <a href="http://kithara.com/en/products/realtime-suite">Kithara</a>. However, since integrating such systems can be very expensive or time consuming, I&#8217;d recommend going with simple and community supported solutions unless necessary.</p>
</div>
<div class="sect2">
<h3 id="_latency_is_not_gaussian">Latency is not Gaussian</h3>
<div class="paragraph">
<p>Finally, I&#8217;d like to stress again that latency practically never follows a Gaussian distribution. The table for these data sets is below.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Samples</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Mean</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>StdDev</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Max</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>(max-mean) /stddev</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Windows 10</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">80,304,595</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.55 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.37</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17.17 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">44.9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OSX 10.9.5</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">65,282,969</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.32 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.03</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.65 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">411</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Ubuntu 16.04</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78,039,162</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.10 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.03 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">293</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Scientific Linux 6.6-rt</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">79.753.643</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.08 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.15 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The max for OSX is more than 400 standard deviations away from the mean. Using only mean/stddev for any sort of latency comparison can produce unwanted results. Aside from giving little to no information about the higher percentiles, there are many cases where systems with seemingly better values exhibit worse actual performance.</p>
</div>
</div>
</div>
</div>]]></description><link>https://ennerf.github.io/2016/08/24/Latency-Operating-Systems.html</link><guid isPermaLink="true">https://ennerf.github.io/2016/08/24/Latency-Operating-Systems.html</guid><category><![CDATA[jHiccup]]></category><category><![CDATA[ Latency]]></category><category><![CDATA[ Sleep]]></category><category><![CDATA[ Operating System]]></category><category><![CDATA[ Windows]]></category><category><![CDATA[ OSX]]></category><category><![CDATA[ Ubuntu]]></category><category><![CDATA[ Scientific Linux]]></category><category><![CDATA[ Real-Time]]></category><category><![CDATA[ Control]]></category><dc:creator><![CDATA[Florian Enner]]></dc:creator><pubDate>Wed, 24 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[First Post]]></title><description><![CDATA[<div class="sect1">
<h2 id="_first_heading">First heading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>text</p>
</div>
</div>
</div>]]></description><link>https://ennerf.github.io/2016/08/23/First-Post.html</link><guid isPermaLink="true">https://ennerf.github.io/2016/08/23/First-Post.html</guid><dc:creator><![CDATA[Florian Enner]]></dc:creator><pubDate>Tue, 23 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[2nd Post]]></title><description><![CDATA[<div class="sect1">
<h2 id="_2nd_header">2nd Header</h2>
<div class="sectionbody">
<div class="paragraph">
<p>second text</p>
</div>
</div>
</div>]]></description><link>https://ennerf.github.io/2016/08/23/2nd-Post.html</link><guid isPermaLink="true">https://ennerf.github.io/2016/08/23/2nd-Post.html</guid><dc:creator><![CDATA[Florian Enner]]></dc:creator><pubDate>Tue, 23 Aug 2016 00:00:00 GMT</pubDate></item></channel></rss>