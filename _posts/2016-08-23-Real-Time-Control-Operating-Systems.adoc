= Real Time Control : Operating Systems

Outline

== (Intro) Real-Time and Latency

Arbitrary requirements are bad. Not much information out there. Planning on blog series about various aspects.

== Measuring Latency

Data is not normally distributed. What is a better way to look at latency? What are tools that do this? How does jHiccup work? Gil Tene mentions coordinated omission, but that is less of a problem for request/response systems.

Reference Nitsan blog and Gil Tene videos

http://psy-lob-saw.blogspot.com/2015/02/hdrhistogram-better-latency-capture.html

== Benchmark Systems

Non-tuned OS, bare install. Mac Mini 2014, Windows 10 (version), Ubuntu 16.04 (Kernel)

== Results (24 hour view)

24 hours in 3 minute intervals. What can create the spikes? How bad is it?

== Results (10 minute view)

10 minute with 1 second intervals. What can we see in a lower time frame?

== Real-Time Linux

Untuned systems aren't good enough for 1KHz control. Describe Linux setup: SCL6, RT kernel, basic optimizations

It still falls flat.

==	Conclusion

It's easy to do 100 Hz control in just about any OS. 1KHz hard real-time requires lots of tuning. Rates are highly dependent on the application. Hard to generalize.

== Old text

Real Time Control: Operating Systems
 
Robotic systems tend to be controlled in 'real-time', which means that a command gets executed within a deadline (fixed period of time). There are 'hard real-time' systems that can never exceed the given deadline, and 'soft real-time' systems that are able to handle occasional outliers.
 
Although the terms may seem familiar, it can be challenging to determine reasonable deadlines and to assess their criticality. This is especially true during the design phase and in academic research settings. Since this is a systemic concern that is difficult to change later, there is a tendency towards high requirements with regards to determinism. However, requirements that are too high can result in significant development efforts that may not yield any benefits in the real world.
 
Over a series of short blog posts, we will try to share some of our own experiences. Today's post will focus on operating systems.
 
Operating Systems
 
The operating system is the base of everything. No matter how good the software stack is, the system is fundamentally bound by the capabilities of the OS, it's scheduler, and the overall load on the system.
 
There is a trade-off between responding in a timely manner and overall performance, battery life, and many other concerns. As a result, the major consumer operating systems are not considered to be deterministic and hard real-time compliant. However, they may still be enough for many applications.
 
jHiccup is a great tool developed by Azul Systems that allows us to measure and record hiccups ('jitter')  at the OS level. These can be caused by a large number of reasons, including swap, indexing tasks, and many more. By running it on an idle system, we can measure the best case scenario.
