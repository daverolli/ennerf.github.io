= Real Time Control : Operating Systems

Outline

1.	Introduction to real-time and blog series. Arbitrary requirements are bad.




2.	Data is not normally distributed. What is a better way to look at latency? What are tools that do this? How does jHiccup work? Gil Tene mentions coordinated omission, but that is less of a problem for request/response systems.



3.	Benchmark system setup and non-tuned operating system setup. 


4.	High-level 24hour view (3 minute intervals)


5.	Zoomed into 10 minutes (1 second intervals)


6.	RT Linux to rule them all. Setup and data.


7.	Conclusion


Real Time Control: Operating Systems
 
Robotic systems tend to be controlled in 'real-time', which means that a command gets executed within a deadline (fixed period of time). There are 'hard real-time' systems that can never exceed the given deadline, and 'soft real-time' systems that are able to handle occasional outliers.
 
Although the terms may seem familiar, it can be challenging to determine reasonable deadlines and to assess their criticality. This is especially true during the design phase and in academic research settings. Since this is a systemic concern that is difficult to change later, there is a tendency towards high requirements with regards to determinism. However, requirements that are too high can result in significant development efforts that may not yield any benefits in the real world.
 
Over a series of short blog posts, we will try to share some of our own experiences. Today's post will focus on operating systems.
 
Operating Systems
 
The operating system is the base of everything. No matter how good the software stack is, the system is fundamentally bound by the capabilities of the OS, it's scheduler, and the overall load on the system.
 
There is a trade-off between responding in a timely manner and overall performance, battery life, and many other concerns. As a result, the major consumer operating systems are not considered to be deterministic and hard real-time compliant. However, they may still be enough for many applications.
 
jHiccup is a great tool developed by Azul Systems that allows us to measure and record hiccups ('jitter')  at the OS level. These can be caused by a large number of reasons, including swap, indexing tasks, and many more. By running it on an idle system, we can measure the best case scenario.
