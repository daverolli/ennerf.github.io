= Using MATLAB for hardware-in-the-loop prototyping
:published_at: 2017-01-15
:hp-tags: MATLAB, Java
:imagesdir: ../images

MATLAB(C) is a programming language and environment designed for scientific computing. It is one of the best languages for developing robot control algorithms and is extremely widespread in the research community. It is generally thought of as an offline programming language, but it is technically possible to add hardware into the loop. This post discusses the most common approaches and compares existing projects.

Prototyping directly on real hardware can significantly speed up development because it reduces the time between considering an idea and getting feedback on whether the algorithm can withstand real world physics. A workflow that requires researchers to port prototype code to another language before being able to test on real hardware can lead to multiple weeks or months being lost in chasing down rabbit holes. Additionally, many controls engineers do not have a computer science background, so requiring knowledge of C++ can pose a significant barrier.

We noticed that over the past few years several groups seem to have identified this as a problem and started to develop ways to control hardware directly from MATLAB. Since there aren't any guidelines for developing such interfaces, we looked at several different projects and compared the approaches they took.

Note that this blog post is purely focused on the MATLAB scripting language and does not discuss Simulink or code generation.

== Technical Background

The main limitation when trying to use MATLAB to interface with hardware is that the language is fundamentally single threaded. It has been designed to allow non-programmers to do complex math operations without needing to worry about computer science concepts like multi-threading and synchronization.

This poses a problem for real-time control because all communications to hardware are forced to happen synchronously in the main thread. For example, if we wanted to run a loop at 100Hz and it took a message ~8ms for a round-trip, the main thread would spend 80% of the available time budget waiting for the response and doing no actual work.

A second hurdle is that while MATLAB is extremely efficient in the execution of math operations, it is not particularly well suited for byte manipulation. This makes it very difficult to develop code that can efficiently create and parse binary message formats that the target hardware can understand.

After having the main thread spend its time on waiting for and parsing the incoming data, there may not be any time left for performing interesting math operations. Pure MATLAB implementations do work for simple applications, e.g., interfacing with an Arduino to gather temperature data or blink an LED, but it is not feasible control complex robotic systems at reasonable rates.

Fortunately, MATLAB does have the ability to interface with other programming languages that allow users to create background threads in order to offload the communications aspect from the main thread. Out of the box MATLAB provides two interfaces to other languages:  https://www.mathworks.com/help/matlab/matlab_external/introducing-mex-files.html[MEX] for calling C++ code and the https://www.mathworks.com/help/matlab/matlab_external/product-overview.html[Java Interface] for calling Java code. There are https://www.mathworks.com/help/matlab/calling-external-functions.html[other interfaces] as well, but those require additional setup steps.  

There are some subtle differences between the capabilities of the MEX and Java interfaces, but at the end of the day the choice mostly comes down to personal preference. Both languages provide enough capabilities for developing sophisticated interfaces, and have orders of magnitude better performance than required.

In order to interface with hardware, MATLAB can either be a part of a distributed system that communicates via messages, or a standalone implementation that communicates with hardware directly. Using a message passing framework (e.g. ROS-messaging) can be easier to develop, but it does add additional burden for setting up the other parts of the system. 

////
== Message Passing Frameworks

In https://en.wikipedia.org/wiki/Message_passing[Message passing] systems components communicate by exchanging messages rather than by calling functions directly. At the core they consist of two parts, a way to exchange messages (e.g. UDP or TCP), and a consistent messaging format. They allow system to be built with components (e.g. processes) that run on different computers, different operating systems, and different programming languages. 

These systems are great for larger research projects as they are very extensible and provide a simple way for prototyping. For example, a new component (e.g. a new walking controller) could be implemented in MATLAB and be integrated seamlessly with the rest of the system. Another common example is that an interface to real hardware can easily be exchanged for an interface to simulated hardware.

The ability to interchange components as well as the robotics community's widespread adoption of message passing systems (ROS, LCM, DDS, etc.) make them a great and relatively easy target for MATLAB bindings.

== Dedicated Product Interfaces

While there aren't many, there are at least a few companies that offer MATLAB interfaces for some of their products. These libraries are typically only useful to customers who bought a particular product.
////

== Distributed Systems


=== Lightweight Communication and Marshalling (LCM)

https://lcm-proj.github.io/tut_matlab.html[LCM] was developed at http://www.mit.edu/[MIT] in 2006 for their entry to DARPA's Urban Challenge. It was the first framework that we know of that came with official bindings for MATLAB. Its MATLAB interface is entirely implemented in Java and does not contain any MATLAB code. The interface consists of 2 classes as well as generated message types.

* The https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/LCM.java[LCM] class provides a way to publish messages and subscribe to channels
* The https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/MessageAggregator.java[MessageAggregator] class receives messages from a background thread and queues them for MATLAB
* The generated Java messages handle the binary encoding and expose fields that MATLAB can access

Since the encoding is done in Java and the messages are received on a background thread, the main thread can spend most of its time on working with the data. Publishing a message could look as follows.

[source,matlab]
----
% Setup
lc = lcm.lcm.LCM.getSingleton();

% Fill message
msg = types.command();
msg.position = [1 2 3];
msg.velocity = [1 2 3];

% Publish
lc.publish('COMMAND_CHANNEL', cmd);
----

Incoming messages are received by subscribing an aggregator to one or more channels, and by picking up messages from the aggregator's queue. Since Java is limited to a single return argument, the _getNextMessage_ call returns a Java type that contains the received bytes as well as the source channel name. The snippet below shows a simplified part of the backing Java code.

[source,java]
----
public class MessageAggregator implements LCMSubscriber {

    public class Message {
    
        // raw data bytes
        final public byte[] data; 
        
        // channel on which it was received
        final public String channel; 
        
        public Message(String channel_, byte[] data_) {
            data = data_;
            channel = channel_;
        }
    }

    public synchronized Message getNextMessage(long timeout_ms) {
    
		if (!messages.isEmpty()) {
		    return messages.removeFirst();
        }

        if (timeout_ms == 0) {
            return null;
        }
        
        // Wait for new message ...
    }
    
}
----

Note that it is important for _getNextMessage_ to have a relatively short timeout (low seconds). Calls that get stuck in Java can cause the UI to become unresponsive and may require users to force close MATLAB without being able to save the workspace. Passing in a timeout of zero provides a non-blocking interface that returns empty if no messages are available.

[source,matlab]
----
% Setup 
lc = lcm.lcm.LCM.getSingleton();
aggregator = lcm.lcm.MessageAggregator();
lc.subscribe('FEEDBACK_CHANNEL', aggregator);

% Listen for messages
timeoutMs = 1000;
while true
    
    % Receive raw message
    msg = aggregator.getNextMessage(timeoutMs);
    
    % Ignore timeouts
    if ~isempty(msg)
    
        % Select message type based on channel name
        if strcmp('FEEDBACK_CHANNEL', char(msg.channel))
    
            % Decode raw bytes to a usable type
            fbk = types.feedback(msg.data);
            
            % Use data
            position = fbk.position;
            velocity = fbk.velocity;
        
        end
    
    end
end
----

A minor issue we found when looking through the code was that the decoding step _fbk = types.feedback(msg.data)_ forces two unnecessary translations due to _msg.data_ being a _byte[]_, which automatically gets converted to and from _int8_. This could result in a noticeable performance hit when receiving larger messages (e.g. images) and could be avoided by adding an overload that accepts a non-primitive type that does not get translated, e.g., _fbk = types.feedback(msg)_. The Java classes also don't implement _Serializable_, which could become a problem when trying to save the workspace. 

Overall, we think that this is well thought out API and a great example of a minimum viable interface that works well in practice.

=== Robot Operating System (ROS)

ROS is by far the most widespread messaging framework in the robotics research community and has been officially supported by Mathworks' https://www.mathworks.com/products/robotics.html[Robotics System Toolbox] since 2014. The MATLAB interface is implemented on top of RosJava. The Simulink code generation aspect leverages ROS C++.

So far we didn't have a chance to use the library in a project, so our impressions are purely based on a quick look at the toolbox files and the compiled Java bytecode. As far as we could tell they built a small Java library that wraps RosJava functionality and provides an interface that is easier to call from MATLAB. Most of the actual logic seems to be implemented in MATLAB code, but they make extensive use of various Java libraries for problems that would be difficult to implement in pure MATLAB, e.g., listing networking interfaces or doing in-memory decompression of images.

The underlying Java interface is completely hidden from users as all of the Java calls happen inside of wrapping MATLAB classes. For example, there is a wrapper class for each Java message type that exposes typical MATLAB properties (get/set) that modify the state of the underlying Java object. Similarly, all Java exceptions get intercepted and wrapped in a MATLAB exception before being exposed to the user. The code below shows a simplified example of such a message wrapper.

[source,matlab]
----
% Simplified example of a message wrapper
classdef WrappedMessage

    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    methods
    
        function name = get.Name(obj)
            %get.Name Get the value for property Name
            name = char(obj.JavaMessage.getName);
        end
        
        function set.Name(obj, name)
            %set.Name Set the value for property Name
            validateattributes(name, {'char'}, {}, 'WrappedMessage', 'Name');
            
            obj.JavaMessage.setName(name);
        end
        
        function out = doSomething(obj)
            try
                out = obj.JavaMessage.doSomething();
            catch javaException
                throw(WrappedException(javaException));
            end
        end
        
    end
end
----

They designed the API such that each topic requires dedicated publishers and subscribers, which is contrary to LCM where each subscriber can listen to multiple channels (topics). This in combination with specifying the type on initialization removes most of the boiler plate code necessary for dealing with message types. The resulting user code is more concise and is arguably more readable than LCM's interface.

[source,matlab]
----
% Setup Publisher
chatpub = rospublisher('/chatter', 'std_msgs/String');

% Fill message
msg = rosmessage(chatpub);
msg.Data = 'Some test string';

% Publish
chatpub.send(msg);
----

They offer three different APIs for receiving messages: blocking calls, non-blocking calls, and callbacks. This allows users to choose the style they are most comfortable with.

[source,matlab]
----
% Setup Subscriber
laser = rossubscriber('/scan');

% (1) Blocking receive
scan = laser.receive(1); % timeout [s]

% (2) Non-blocking latest message (may not be new)
scan = laser.LatestMessage;

% (3) Callback
callback = @(msg) disp(msg);
subscriber = rossubscriber('/scan', @callback);  
----

Overall, we found that the ROS support toolbox looks very nice and is a great example of how seamless external languages could be integrated with MATLAB. We also really liked that they offered a way to load log files (rosbags).

One concern we had was that there didn't seem to be a simple non-blocking way to check for new messages, e.g., a _hasNewMessage()_ method or functionality equivalent to LCM's _getNextMessage(0)_. This would probably be useful for applications that combine data from multiple topics that may arrive at different rates (e.g. sensor feedback and joystick input events). We checked whether this behavior could be emulated by specifying a very small timeout, but any value below 0.1s seemed to never successfully return.

[source,matlab]
----
try
    msg = sub.receive(0.1); % below 0.1s always threw an error
    % ... use message ...
catch ex
    % ignore
end
----

=== Data Distribution Service (DDS)

In 2014 Mathworks also added a https://www.mathworks.com/hardware-support/rti-dds.html[support package for DDS], which is the messaging middleware that ROS 2.0 is based on. It supports MATLAB and Simulink, as 
well as code generation. 

We didn't have all the requirements to get it running, so we don't know much about the underlying implementation. Looking at the examples, the code for sending and receiving messages looks very similar to the previous examples.

[source,matlab]
----
% Setup
DDS.import('ShapeType.idl','matlab');
dp = DDS.DomainParticipant

% Create message
myTopic = ShapeType;
myTopic.x = int32(23);
myTopic.y = int32(35);

% Send Message
dp.addWriter('ShapeType', 'Square');
dp.write(myTopic);

% Receive message
dp.addReader('ShapeType', 'Square');
readTopic = dp.read();
----

=== ZeroMQ

ZeroMQ is another asynchonous messaging library that is popular for building distributed systems. It only handles the messaging aspect, so users need to supply their own wire format.

https://github.com/smcgill3/zeromq-matlab[ZeroMQ-matlab] is a MATLAB interface to ZeroMQ that was developed at UPenn between 2013-2015. It is implemented as a single MEX function that results in different actions depending on the first argument. State is maintained by using socket IDs that need to be passed in by the user at every call. The code below shows a simplified snippet of the send action.

[source,c++]
----
// Grab command String
if ( !(command = mxArrayToString(prhs[0])) )
	mexErrMsgTxt("Could not read command string. (1st argument)");

// ...
if (strcasecmp(command, "send") == 0){
	// ... (argument validation)
	
	// retrieve arguments 
	socket_id = *( (uint8_t*)mxGetData(prhs[1]) );
	size_t n_el = mxGetNumberOfElements(prhs[2]);
	size_t el_sz = mxGetElementSize(prhs[2]);		
	size_t msglen = n_el*el_sz;
	
	// send data
	void* msg = (void*)mxGetData(prhs[2]);
	int nbytes = zmq_send( sockets[ socket_id ], msg, msglen, 0 );
	
	// ... check outcome and return
}
----

There is not a lot of documentation, but we assume that the resulting code should look something like the following snippet.

[source,matlab]
----
// Setup
subscriber = zmq( 'subscribe', 'tcp', '127.0.0.1', 43210 );
publisher = zmq( 'publish', 'tcp', 43210 );

// Publish data
bytes = uint8(rand(100,1));
nbytes = zmq( 'send', publisher, bytes );

// Receive data
receiver = zmq('poll', 1000); // polls for next message
[recv_data, has_more] = zmq( 'receive', receiver );

disp(char(recv_data));
----

=== Hand Proprioception and Touch Interfaces (HAPTIX)

OSRF developed a http://www.osrfoundation.org/haptix-simulation-of-prosthetic-devices/[MATLAB interface] for DARPA's  http://www.darpa.mil/program/hand-proprioception-and-touch-interfaces[HAPTIX] program that allows users to interface with real hardware as well as a step-in Gazebo simulation. They chose to create an API that hides the messaging part from the user and exposes more product specific functions. The underlying implementation is based on http://ignitionrobotics.org/libraries/transport[ignition-transport] which is a combination of ZeroMQ with Protobuf as the wire format. 

At the top level, the API consists of https://bitbucket.org/osrf/haptix-comm/src/a961986b0254a3dbcabcc89ba14f78915d5d968a/matlab/[several MATLAB functions] that provide help text and forward calls to an underlying MEX function.

[source,matlab]
----
% Example for a forwarding function
% <help text>
function result = hxs_add_model(sdf, name, pos, orient, gravity_mode)
  result = hxgz('add_model', sdf, name, pos, orient, gravity_mode);
end
----

The MEX code is implemented in a similar way as the ZeroMQ project in that there is a single function implementation (https://bitbucket.org/osrf/haptix-comm/src/a961986b0254a3dbcabcc89ba14f78915d5d968a/matlab/hxgz.c[hxgz.c]) that takes a string as the first argument to execute a corresponding action. The MEX function internally translates the other input arguments according to the action, and calls a corresponding function in their C API. The underlying C code then sends an appropriate message via ZeroMQ. The snippet below shows a simplified example for an action implementation.

[source,c++]
----
// Dispatch to the appropriate function based on the first argument
// ...
else if (!strcmp(funcName, "add_model"))
    hxgzs_add_model(nlhs, plhs, nrhs-1, prhs+1);

// ...   
void hxgzs_add_model(int nlhs, mxArray *plhs[],
                int nrhs, const mxArray *prhs[]) {
    // ... input translation
    
    // Call to C API
    if (hxs_add_model(sdf, name, x, y, z,
                      roll, pitch, yaw, gravity_mode, &model) != hxOK)
        mexErrMsgIdAndTxt("HAPTIX:hxs_add_model", hx_last_result());

  // ... output translation
  plhs[0] = model_to_matlab(&model);
}

----

According to their http://gazebosim.org/haptix[documentation] the MATLAB API was generated from their C API. Investing time into code generators is a heavily recommended practice since maintaining four or more translation layers for every function can be very tedious and is extremely difficult to extend and maintain manually.

Below is a copy of an http://gazebosim.org/tutorials?cat=haptix&tut=haptix_matlab[example] from their website.

[source,matlab]
----
counter = 0;

hx_connect();

deviceInfo = hx_robot_info();

% Uncomment this block to start logging.
% hxs_start_logging('/tmp/log/')

while counter < 250
  cmdSent = tic;

  % Initialize the command scalar structure.
  cmd.ref_pos = [];
  cmd.ref_vel = [];
  cmd.ref_vel_max = [];
  cmd.gain_pos = [];
  cmd.gain_vel = [];

  % Indicate that the positions we set should be used.
  cmd.ref_pos_enabled = 1;
  % We're not setting it, so indicate that ref_vel should be ignored.
  cmd.ref_vel_enabled = 0;
  % We're not setting it, so indicate that ref_vel_max should be ignored.
  cmd.ref_vel_max_enabled = 0;
  % We're not setting it, so indicate that gain_pos should be ignored.
  cmd.gain_pos_enabled = 0;
  % We're not setting it, so indicate that gain_vel should be ignored.
  cmd.gain_vel_enabled = 0;

  % Create a new command based on a sinusoidal wave.
  for n = 0:deviceInfo.motor_count
    cmd.ref_pos(end + 1) = 350 * 0.5 * sin(0.05 * 2.0 * pi * counter * 0.08);
    % We could set a desired maximum velocity
    % cmd.ref_vel(end + 1) = 1.0;
    % cmd.ref_vel_max(end + 1) = 1.0;
    % We could set a desired controller position gain
    % cmd.gain_pos(end + 1) = 1.0;
    % We could set a desired controller velocity gain
    % cmd.gain_vel(end + 1) = 1.0;
  end

  % Send the new joint command and receive the state update.
  state = hx_update(cmd);

  counter = counter + 1;

  % Busy wait. pause() is not accurate enough on Windows.
  elapsedCmd = toc(cmdSent);
  while elapsedCmd < 0.02
    elapsedCmd = toc(cmdSent);
  end
end

% Uncomment this block to stop logging.
% hxs_stop_logging()

hx_close();
----

Overall we found their implementation to be done pretty well and it was nice to see that they went through significant efforts to support researchers. It was also nice to see a hook for enabling and disabling data logging.

The usability could probably be improved a bit by adding a helper function that returns a default command struct (or making it a class so that users can't mess with the fields), e.g., _hxs_command_struct()_, and by accepting NaN or empty as being disabled rather than using fields with separate boolean flags. https://bitbucket.org/osrf/haptix-comm/src/a961986b0254a3dbcabcc89ba14f78915d5d968a/matlab/hx_update.m[_hx_update()_] could also benefit from a second return argument that indicates whether the returned state is new, and a blocking call with timeout to get rid of the busy loop.

== Standalone Systems

=== Arduino

Mathworks offers a https://www.mathworks.com/hardware-support/arduino-matlab.html[support package for Arduino] that allows users to interface with the pins on an https://www.arduino.cc/[Arduino] in real-time. It is implemented as a library that does not require external processes. Since the Arduino requires firmware to run, the first instantiation automatically programs a Mathworks supplied binary to the Arduino that lets MATLAB establish a serial connection and exchange information. Dimming an LED based on some analog input could look as shown below.

[source,matlab]
----
% Setup
a = arduino('com1','Mega2560');
potentiometer = 'A0';
led = 'D3';

% Dim LED base on potentiometer
while true
    value = readVoltage(a, potentiometer);
    writePWMVoltage(a, led, value);
end
----

We thought that this was a very nice interface for Arduino users. 

However, it also highlights the performance problems caused by the synchronous programming model. On our test machine we were only able to get about 80 operations (reads or writes) per second, so the above loop would run at maximum 40 Hz. This is enough for simple Arduino-type problems, but far too slow for serious robotics applications.

Note that most of the overhead comes from waiting for device responses, so code generated from Simulink models that gets deployed locally on the device should be able to run significantly faster.

=== HEBI Robotics' Modular Actuators

We decided to implement our own http://hebirobotics.com/matlab[MATLAB API] as a standalone library in order reduce the number of setup steps and to provide an overall better user experience. The details of the implementation will be covered in a separate blog post.

The code below shows a full example of kinesthetic control of two 16-DoF snake robots where one acts as a master, and the other one as a slave that copies its motion. A single run lasts 60 seconds. The slave robot's data is automatically logged to disk and the position tracking error is plotted after each trial.

[source,matlab]
----
% Setup
master = HebiLookup.newConnectedGroupFromName('*', 'SA128');
slave = HebiLookup.newConnectedGroupFromName('*', 'SA119');
limpCmd = CommandStruct();
limpCmd.torque = zeros(1, master.getNumModules());

% Start logging to disk (background thread)
slave.startLog();

% Run Trial
cmd = CommandStruct();
t = t0;
while toc(t) < 60

    % Copy master feedback to slave motion
    fbk = master.getNextFeedback();
    cmd.position = fbk.position;
    cmd.velocity = fbk.velocity;
    slave.set(cmd);
    
    % Keep master in zero torque mode
    master.set(limpCmd);

end

% Stop logging and plot position error
data = slave.stopLog();
positionError = data.positionCmd - data.position;
plot(data.time, positionError);
----

 TODO: Add MSI picture or video? Alternatively, switch to a sine wave and add video of sidewinding? 



== Other Hardware Interfaces

Since this post is already very long, we were reluctant to include any more examples. Below is a list of other APIs that we are aware of but for various reasons didn't cover in more detail.

[width="100%",options="header",cols="1a,3a"]
|====================
| Project | Notes

| https://www.mathworks.com/hardware-support/android-sensor.html[Android Sensor Support] 
| Periodically sends data from the mobile device to the MATLAB host

| http://www.robodk.com/Matlab-API.html[RoboDK]
| Sends strings via TCP to their main simulation app

| https://henschel-robotics.ch/hdrive/software/[Henschel Servos] 
| https://github.com/ragavsathish/RabbitMQ-Matlab-Client[RabbitMQ] 
| Simple Java wrapper for RabbitMQ 

| http://support.robotis.com/en/software/dynamixel_sdk/usb2dynamixel/windows/matlab.htm[Robotis Dynamixel]
| C library that provides utility functions to manually create the protocol structure

| https://sourceforge.net/projects/urbi/?source=typ_redirect[URBI] (http://agents.csse.uwa.edu.au/aibosig/resources/downloads/tutorial_liburbiMatlab_0.1.pdf[tutorial])
| Seems to be deprecated

| http://fileadmin.cs.lth.se/cs/education/MMKN30/Nao/download/Documentation/dev/matlab/index.html[Aldebaran Nao]
| Seems to be deprecated
| Creates XML messages and sends them to a service running locally on the servo

| https://github.com/ragavsathish/RabbitMQ-Matlab-Client[RabbitMQ] 
| Simple Java wrapper for RabbitMQ 

| http://support.robotis.com/en/software/dynamixel_sdk/usb2dynamixel/windows/matlab.htm[Robotis Dynamixel]
| C library that provides utility functions to manually create the protocol structure

| https://sourceforge.net/projects/urbi/?source=typ_redirect[URBI] (http://agents.csse.uwa.edu.au/aibosig/resources/downloads/tutorial_liburbiMatlab_0.1.pdf[tutorial])
| Seems to be deprecated

| http://fileadmin.cs.lth.se/cs/education/MMKN30/Nao/download/Documentation/dev/matlab/index.html[Aldebaran Nao]
| Seems to be deprecated

|====================

////

== Related Work

* Interfaces to message passing frameworks. Usually includes background threading. (Async) Requires external applications to communicate with robot.

* Interfaces to the raw communication protocol. Usually relies on main thread for the communication aspect. (Sync)


* Other

Table with features? Name, Async, Language, Performance (?), Protocol (binary/text), Object Oriented?, Comment



// Example1:

Message passing systems don't work very well for prototyping with modular systems. For example, consider a case of kinesthetic control where the feedback of a master robot is used to control a second slave robot. This would require changes to the messages, which always results in significant overhead. Definition need to be changed, messages need to be generated, the receiving process needs to be modified, everything has to be recompiled for the target platform and so on. This overhead is justifiable for static systems that live for a long time, but it is a dealbreaker for modular systems that were constructed and programmed in an hour for a quick YouTube video.


When showing syntax for other APIs that show setting of a position command, we can show the MSI demo of 1 limp robot controlling position/velocity on another. Maybe include logging as well.

Performance is actually better than original C++ due to no message passing overhead.

Original implementation required additional process that connects to robot and handles other message type.
////

== Final Notes

Contrary to the situation a few years ago, nowadays there are several available interfaces that allow researchers to do hardware-in-the-loop prototyping directly from MATLAB. If for some reason none of the existing options work for you and you need to write your own, we would recommend to start with an LCM-like implementation and to add complexity as needed. 

Interfaces that expose MATLAB code can provide a much better and more consistent user experience (e.g. help documentation), but they almost always require significant time investments to maintain all of the involved layers and to write tools for code generation.

If there is no clear preference between C++ and Java, we would recommend to at least start with a Java implementation. MEX interfaces require a lot of conversion code that MATLAB would automatically handle for Java calls.

 TODO: fix rest of the intro

Keep in mind that research is also a very dynamic environment where needs and requirements can change all the time. Some of us used to work on the  http://biorobotics.ri.cmu.edu/robots/index.php[snake robot project] at http://www.cmu.edu[CMU], which was entirely based on LCM. We used LCM's MATLAB bindings extensively, but we eventually hit a point where we needed to deal with many messages coming from many channels. This  significantly increased the parsing overhead and made the resulting code very difficult to maintain. We later built a specialized Java API that hid subscriptions and message conversion internally and exposed more convenient methods to user, similar to OSRF's approach for HAPTIX. 

The resulting API looked similar to the following.

////
As a side note, the http://biorobotics.ri.cmu.edu/robots/index.php[snake robot project] that we used to work on at http://www.cmu.edu[CMU] was entirely based on LCM. We used the MATLAB bindings extensively, but we eventually hit a point where we needed to deal with many messages coming from many channels. This  significantly increased the parsing overhead and made the resulting code very difficult to maintain. We later built a specialized Java API that hid subscriptions and message conversion internally and exposed more convenient methods to users. The resulting API looked similar to the following.
////

[source,matlab]
----
% Setup
lcmBridge = org.biorobotics.matlab.LcmBridge();

% Control
while true

    if lcmBridge.hasNewFeedback()
        
        % access feedback
        fbk = lcmBridge.getFeedback();
        headPose = lcmBridge.getHeadPose();
        mocap = lcmBridge.getMocapMarkers();
        joy = lcmBridge.getJoystickState();
        
        % ... do stuff ...
        
        % command robot
        lcmBridge.setAngles(zeros(1,16));
    
    end

end
----

This custom API worked very well for our lab until we started building a much more sophisticated generation of hardware that had many tuning options that users needed to access. Due to the nature of message passing systems, each new sensor or settable option required changes to every level of the stack, including the firmware, the network protocol, the receiving process, the message type, as well as several API layers. It quickly became a maintenance nightmare to go through this many layers and we started to eliminate several of them by writing more sophisticated APIs that communicated with the hardware directly.
