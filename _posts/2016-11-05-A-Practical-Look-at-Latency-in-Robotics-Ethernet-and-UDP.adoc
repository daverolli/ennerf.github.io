= A Practical Look at Latency in Robotics : Ethernet and UDP
:published_at: 2016-11-05
:hp-tags: Latency, Ethernet, UDP
:imagesdir: ../images

== Intro

The User Datagram Protocol (UDP) is unreliable, packets may be lost, reordered, and could even be delayed by an arbitrarily long time. These shortcomings make standard UDP seem non-deterministic and a really bad choice for controlling real-time systems. Luckily modern network components have largely solved these issues and performance in practice can be surprisingly good.

Early networks were built using 'Hubs' that share a single channel for all network ports. This results in a large https://en.wikipedia.org/wiki/Collision_domain[Collision Domain] that can cause packet loss whenever more than one sender transmits a packet at the same time. Nowadays Hubs have been replaced with 'Switches' that have dedicated connections for each port in order to isolate collision domains. Connections also tend to be full-duplex, which means that there are dedicated lines for transmitting and receiving data. Since all communications are done over dedicated lines, collisions on the physical (wire) level should be a thing of the past.

In the common https://en.wikipedia.org/wiki/Store_and_forward[Store-and-Forward] switching architecture all packets get buffered by the Switch and are then forwarded to the appropriate receiver port. This adds a latency cost that scales linearly with the number of switches that a packet has to go through. The alternative https://en.wikipedia.org/wiki/Cut-through_switching[Cut-through] switching approach can forward packets before they are fully received, which can have positive impacts on latency especially with very large packets.

<TODO: combine these concepts somehow>

//When more than one component try to communicate, there may be a collision that causes packets to be dropped. Modern networks use 'Switches' that have dedicated connections for each port to isolate collision domains. Additionally, connections tend to be full-duplex, so there are dedicated lines for transmitting and receiving data. Depending on the architecture, packets get buffered and sent to the appropriate port (Store-and-Forward) or directly passed through without evaluation (Cut-Through). Thus, switched networks should never have any packets that get dropped due to collisions. Note that packets can still be lost due to buffer overflows and/or too much load on a system. There is also a latency cost associated with each 'hop' (or buffer) that a packet has to go through.

// re-read
// http://www.cisco.com/c/en/us/products/collateral/switches/nexus-5020-switch/white_paper_c11-465436.html
// https://www.lantronix.com/resources/networking-tutorials/network-switching-tutorial/

Similarly, reordering (in the sense that a stream of packets coming from a single source can arrive out of order) may be relevant for internet communications, but generally does not apply to local networks without redundant routes and load balancing. Depending on the driver implementation it can theoretically happen on a local network, but I have yet to observe a single case.

There are a number of competing networking standards that originated in industrial automation that are built on top of standard Ethernet. They are able to guarantee certain levels of determinism by enforcing tight control over the network layout and by limiting the components that can be connected. However, controlling standard networks in a similar manner can also produce quite good results.

== Benchmark Setup

In order to mitigate jitter caused by the operating system and it's device drivers, I've tried to setup a benchmark that measures the communications latency between two dedicated embedded systems.

1. Sender sends packet to receiver in fixed intervals
2. Receiver echoes packet back to sender
3. Sender measures round trip time and sends results to logging server
4. Logging server persists data to disk

As the sender and receiver devices I'm using two HEBI Robotics I/O Boards. It's a product that we haven't advertised yet, but customers usually use it to integrate actuators with external devices or to get various sensor input into MATLAB. It has 48 pins that serve a variety of functions (analog/digitial I/O, PWM, Encoder input, etc.) that can be accessed remotely via network. It sports a STM32f407 microcontroller and a 100 Mbit network port. For this benchmark I've programmed custom firmware (<TODO: add code snippet for sender and receiver>) to test the network stack.

image::udp/io-boards.jpg[HEBI Robotics IO Board]

Since multi-day logs can't be stored directly on the device, I've setup a Java server for data logging. The main socket handler writes incoming packets into a double buffered structure that can be persisted by a background thread without halting the packet handler. The synchronization between the threads is done using a http://stuff-gil-says.blogspot.com/2014/11/writerreaderphaser-story-about-new.html[WriterReaderPhaser], which is a synchronization primitive that is very useful for persisting events that are represented by a small amount of data. <TODO: add code snippet>

The resulting binary data was loaded into MATLAB(C) for analysis and to generate the plots.

== Ethernet Packet Structure

Data packets on the wire include various types of overhead in addition to the actual payload. The minimum overhead is 66 bytes. Additionally, Ethernet Frames have a minimum size of 84 bytes, which makes the minimum payload for a UDP datagram 18 bytes.

.UDP/IP Packet Size
[width="100%",options="header,footer",cols="a,a,a"]
|====================
| Protocol | Item | Size (byte) 

| https://en.wikipedia.org/wiki/Ethernet_frame[Ethernet II] | Preamble | 7
|  | Start of Frame Delimiter | 1
|  | MAC Header + CRC checksum | 18 (no optional fields)
|  | Interpacket gap | 12

| https://en.wikipedia.org/wiki/IPv4[Internet Protocol (IPv4)] | IP Header | 20  (no optional fields)


| https://en.wikipedia.org/wiki/User_Datagram_Protocol[User Datagram Protocol (UDP)] | UDP Header | 8

|====================

All of the benchmarks in this post were done using a payload of 200 bytes. Thus, the actual packet size on the wire is 266 bytes after including all overhead. This may seem high to users to are used to dealing with serial protocols, but it is representative of what we are using in practice. For comparison, the feedback packets of our actuators use about 185-215 bytes payload. Requesting the state of all pins of an I/O board currently fills about 300 bytes payload.

The theoretical time to send 266 bytes over the wire is 20.3us over 100 Mbit/s Ethernet and 2.03us over 1 Gbit/s Ethernet.

== Best case single switch

test IO board to IO board (100)

operating system jitter, network jitter, clock drift (reference IEEE 1588v2)

== Latency cost of switch (100/1000)

image::udp/io-boards-100mbit-switch.jpg[]

http://ww1.microchip.com/downloads/en/DeviceDoc/KSZ8863MLL_FLL_RLL_DS.pdf[MICREL KSZ8863]

http://www.downloads.netgear.com/files/GDC/GS105/GS105_datasheet_04Sept03.pdf[NETGEAR ProSAFE GS105]

image::udp/io-boards-gbit-switch.jpg[]

Gbit switch to switch vs going through a 3 port embedded switch in an X5.

image::udp/comparison-switch-latency.png[]
image::udp/comparison-switch-latency-percentiles.png[]


== Larger networks

http://www.downloads.netgear.com/files/GDC/GS748Tv1/GS748T_ds_03Feb05.pdf[NETGEAR ProSAFE GS748T]

40 IO boards responding within <1 us.

image::udp/multiple-boards.jpg[]

== Conclusion

