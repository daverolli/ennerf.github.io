= Using optional arguments in the MATLAB Java interface
:published_at: 2017-01-25
:hp-tags: MATLAB, Java
:imagesdir: ../images
:source-highlighter: none

++++
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
++++

APIs for MATLAB that were implemented in other languages often don't look like native MATLAB interfaces. We looked at providing a seamless interface that looks like native code. 

== Motivation

After several iterations on our MATLAB APIs we became somewhat frustrated because despite significant efforts, the APIs never felt quite like native MATLAB code. The main reason for this was that we limited ourselves to fixed numbers of arguments to simplify the implementation. This worked well for simple use cases, but we kept running into advanced use cases that resulted in confusing behavior or ugly syntax. 

Consider the following (real) example for controlling robot actuators: The majority of users wants to only send position/velocity/torque commands to each joint. However, some expert users would additionally like to set corresponding gains (https://en.wikipedia.org/wiki/Gain_scheduling[gain scheduling]) as well as LED colors for synchronization or debugging with video data from a high-speed camera.

With fixed argument calls this could typically be approached in a few different ways, e.g., as separate method calls, as transactions, or with empty arguments.

[source,matlab]
----
% (1) Separate method calls
sendCommand(cmd);
sendLed(led);
sendGains(gains);

% (2) Transactions
startMessage();
addCommand(cmd);
addLed(led);
addGains(led);
sendMessage();

% (3) Empty arguments
sendMessage(cmd, [], led);
----

All of these options come with drawbacks. (1) divides commands up into three different messages that may not get there at the same time, (2) adds boiler plate code and complicates the common case, and (3) results in code that is difficult to read and write. In reality this gets much worse since there are more than 20 other parameters that users may want to set, e.g., _safety limits_,  _reset flags_, _name/id_, _calibration commands_. 

Some groups approached similar problems by combining gains and commands into a single struct, but in our case this became overwhelming (>60 fields) and messed with autocomplete in cases like 'position' vs. 'positionKp'. 

At the end of the day, none of these options are particularly satisfying. It'd be much more appropriate to map optional functionality to actual optional parameters. MATLAB already established a way to do this by splitting arguments into _required_, _optional_, and _key/value parameter_ arguments. The example below shows some different ways to call the plot command.

[source,matlab]
----
plot(x,y);
plot(x,y,'--rs');
plot(x,y,'--rs', ...
    'LineWidth', 2,...
    'MarkerEdgeColor', 'k', ...
    'MarkerFaceColor', 'g', ...
    'MarkerSize', 10)
----

The problem stated earlier could be solved in the same way, e.g.,

[source,matlab]
----
% common use case
sendMessage(cmd);

% expert use case
sendMessage(cmd, 'led', led, 'gains', gains);
----

This way the syntax matches built-in functions and is much more intuitive for MATLAB users. Additionally, the string arguments make the code much more readable because it is immediately obvious which argument is at which position.

Unfortunately, this does not work with a fixed argument approach and requires dynamic parsing and more input validation. However, adding dynamic parsing resulted in far fewer requests from confused users and we had people come in and were able to control robots within minutes. Below we show some options for implementing this.


== InputParser

MATLAB's https://www.mathworks.com/help/matlab/ref/inputparser-class.html[inputParser] helps to parse function inputs of the standard format. It supports the different argument types (required, optional, parameter) as well as default values and input validation.

[source,matlab]
----
% set defaults
defaultHeight = 1;
defaultUnits = 'inches';
defaultShape = 'rectangle';
expectedShapes = {'square','rectangle','parallelogram'};

% parse inputs
p = inputParser;
p.addRequired('width',@isnumeric);
p.addOptional('height',defaultHeight,@isnumeric);
p.addParameter('units',defaultUnits);
p.addParameter('shape',defaultShape, @(x) any(validatestring(x,expectedShapes)));

p.parse(varargin{:});
a = p.Results.width .* p.Results.height;
----

We could use this built-in parser for parsing user inputs and then forward the output to a fixed argument call.

[source,matlab]
----
function [out] = myMethod(this, varargin)
    % parse inputs
    p = inputParser;
    % ... setup ...
    p.parse(varargin{:});
    r = p.Results;
    out = myMethod(this.javaObj, r.width, r. height, r.units, r.shape);
end
----

This works well for some cases, but we also ran into some limitations with this approach. Some of them were

* Automated end-to-end tests now have a dependency on MATLAB
* No good way to distinguish between default value and not-set (e.g. empty could be a valid user-set value)
* Validation can become very complicated
* Error messages are not useful for cases with non-trivial validation
* There are methods with >20 parameters, at which point this approach becomes unmaintainable and actually degrades performance.

Thus, we ended up implementing our own input parser equivalent entirely behind the Java barrier.


== Wrapper Classes

Our earlier API versions were actually implemented purely in Java without any MATLAB code at all. While the performance was very good and the resulting code looked identical to native MATLAB code, we ran into fundamental limitations with help documentation, setup steps, and access to destructors. We provided help documentation through a call to a _.help()_ method, but this confused users more than we anticipated. Additionally, having to call a setup script to import the right namespaces, as well as doing manual resource management for some cases were confusing and inconvenient. In general, all elements that did not perfectly fit the standard MATLAB paradigm 

In subsequent versions we created MATLAB wrapper classes that provide help documentation and automatically handle any necessary setup and dependency management. This has greatly simplified initialization and removed the most confusing parts. We now believe that users should not even be aware of the fact that there is another language underneath.

[source,matlab]
----
classdef (Sealed) WrapperClass
    %WrapperClass general documentation

    methods(Access = public)
    
        function this = WrapperClass()
            %WrapperClass short documentation
            import namespace.JavaClass;
            this.javaObj = JavaClass(); % corresponding Java object
        end
        
        function [out] = myMethod(this, varargin)
            %myMethod documentation
            out = myMethod(this.obj, varargin{:}); % forwards calls
        end

    end
    
    properties(Access = private, Hidden = true)
        javaObj % backing implementation
    end
    
end
----

Our wrapping methods typically don't contain any logic and purely forward all calls. Note that the performance hit of this additional method call is completely negligible. This is especially true after the advancements in MATLAB's JIT compiler in 2015b.

== Handling Varargs in Java

In our attempt to replicate this functionality in Java, we immediately faced the first issue. The Java language has an equivalent of MATLAB's _varargin_ called _varargs_, which can accept zero or more arguments of the given type.

[source,Java]
----
public void varargsMethod(Object... args){}
----

Unfortunately MATLAB does not support this correctly and interprets _Object..._ the same as the non-varargs _Object_ and expects exactly one argument. However, the same functionality can still be supported by creating method overloads that gather input arguments.

[source,Java]
----
public final class JavaClass {

    public Object myMethod() {
        return myMethod0();
    }

    public Object myMethod(Object o0) {
        return myMethod0(o0);
    }

    public Object myMethod(Object o0, Object o1) {
        return myMethod0(o0, o1);
    }

    public Object myMethod(Object o0, Object o1, Object o2) {
        return myMethod0(o0, o1, o2);
    }

    public Object myMethod(Object o0, Object o1, Object o2, Object o3) {
        return myMethod0(o0, o1, o2, o3);
    }

    public Object myMethod(Object o0, Object o1, Object o2, Object o3, Object o4) {
        return myMethod0(o0, o1, o2, o3, o4);
    }

    private Object myMethod0(Object... args) {
        // parse arguments and implement functionality
        MyMethodParser p = MyMethodParser.parse(args);
        return args;
    }
    
}
----

Unfortunately, this quickly becomes unmaintainable for large APIs that have many methods where each can have many arguments. As a result we developed annotation processors that can automatically generate most of the boiler plate code necessary for interfacing with MATLAB.

[source,Java]
----
@MatlabMethod(maxArgs = 20)
public Object myMethod0(Object... args){
    // ...
}
----

As of this point we have not open sourced these annotation processors, but we may do so in the future.

////
* We need to support arbitrary number of arguments, but Java's varargs _Object..._ does not work

In Java _Object..._ means zero or more argument of the given type. MATLAB unfortunately interprets this equivalent to _Object_ and expects exactly one argument. We ended up working around this limitation by creating many overloads for every method.
////


== Type Conversions

////

The second issue we encountered was that 

* Parameters are all _Object_, so we loose any type conversion and need to support all possible combinations

The MATLAB-Java interface usually handles type conversion automatically to match the target method. This means that a Java method that expects a double will always see a double, no matter whether the actual input type used to be single or int16. However, if the method accepts _Object_, MATLAB converts to the closest matching data type, e.g., _single_ and _int8_ convert to _float_ and _byte_ respectively. 

////

The most extreme example we've so far encountered was a method to set the led color of our components. The goal was to support all representations of colors that MATLAB users are familiar with, and to allow convenient syntax for setting multiple colors at once.

Thus, for a single module it needs to support the following representations:

* Strings: 'red', 'blue', 'green', ...
* Shorthand: 'r', 'b', 'g', ...
* Array: [1 0 0], [0 1 0], [0 0 1], ...

Additionally, more than one module may be targeted in a single call, so it also needs to support the corresponding vector/matrix versions. MATLAB numbers can be practically any data type, so the parser needs to support all of the following Java types, as well as provide input validation with proper error checks.

[source,]
----
String, String[], 
byte[], short[], int[], long[], float[], double[], 
byte[][], short[][], int[][], long[][], float[][], double[][]
----