= Latency : Operating Systems
:published_at: 2016-08-24
:hp-tags: jHiccup, Latency, Sleep, Operating System, Windows, OSX, Ubuntu, Scientific Linux, Real-Time, Control

//NOTE: Keep X in Mind
//image::cover-image.jpg[150, 250, link="http://docs.hebi.us"]
//video::KCylB780zSM[youtube]

== Introduction

// Arbitrary requirements are bad. Not much information out there. Planning on blog series about various aspects.

Robotic systems tend to be controlled in _real-time_, which means that a command gets executed within a _deadline_ (fixed period of time). There are _hard real-time_ systems that can never exceed the given deadline, and _soft real-time_ systems that are able to occasionally handle reasonable outliers.
 
Although there is a lot of information on the theoretial definition of these terms, it can be challenging to determine reasonable deadlines for a practical application. This is especially true for research environments that build unique mechanisms.

Unfortunately, the control scheme is a systemic concern that can impact the entire system architecture. This can be very difficult to change later on, so there is a tendency towards high requirements with regards to determinism. However, requirements that are too high can result in significant development efforts that may not yield any benefits in the real world.

There is also a lot of folklore about the reliablity and performance of various components. I have been in countless debates where people have tried to convince me that a proposed system has no chance of working, not knowing that it had already been implemented and been running without issues. This is partly because there is very little useful data on latency out there. Most benchmarks focus only on throughput, and some that do include latency were measured incorrectly.

Over a series of blog posts, I'll try to share some my own experiences and data sets. Today's post will focus on operating systems.

=== Measuring Latency

// Data is not normally distributed. What is a better way to look at latency? What are tools that do this? How does jHiccup work? Gil Tene mentions coordinated omission, but that is less of a problem for request/response systems.

When looking at latency it is important to understand that the data is not normally distributed. I have seen many data sets where the worst observed case was more than 1000 standard deviations away from the mean. Thus, looking only at the mean and std-dev can be very misleading.

A better way to look at latency is via histograms and percentile plots.

jHiccup is a great tool developed by Azul Systems that allows us to measure and record hiccups ('jitter')  at the OS level. These can be caused by a large number of reasons, including swap, indexing tasks, and many more. By running it on an idle system, we can measure the best case scenario.

Reference Nitsan blog and Gil Tene videos

http://psy-lob-saw.blogspot.com/2015/02/hdrhistogram-better-latency-capture.html

== Operating Systems
 
The operating system is the base of everything. No matter how good the software stack is, the system is fundamentally bound by the capabilities of the OS, it's scheduler, and the overall load on the system.
 
There is a trade-off between responding in a timely manner and overall performance, battery life, and many other concerns. As a result, the major consumer operating systems are not considered to be deterministic and hard real-time compliant. However, they may still be enough for many applications.

== Benchmark Systems

To start off with, I've tried to

Mac Mini 2014

[cols="3*"]
|===
/Windows 10
|Web Browser

|Ruby
|Programming Language

|TorqueBox
|Application Server
|===


Non-tuned OS, bare install. Mac Mini 2014, Windows 10 (version), Ubuntu 16.04 (Kernel)

== Results (24 hour view)

24 hours in 3 minute intervals. What can create the spikes? How bad is it?

== Results (10 minute view)

10 minute with 1 second intervals. What can we see in a lower time frame?

== Real-Time Linux

Untuned systems aren't good enough for 1KHz control. Describe Linux setup: SCL6, RT kernel, basic optimizations, highest priority.

It still falls flat.

==	Conclusion

It's easy to do 100 Hz control in just about any OS. 1KHz hard real-time requires lots of tuning. Rates are highly dependent on the application. Hard to generalize.
