= Using optional arguments in the MATLAB Java interface
:published_at: 2017-01-25
:hp-tags: MATLAB, Java
:imagesdir: ../images
:source-highlighter: none

++++
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
++++

== API Design

One thing that all of the other work referenced above have in common is that they call into other languages with a set number of arguments. We did this for a long time as well and had great experiences with it, but the APIs didn't quite feel like native MATLAB code. It worked well for simple use cases, but we kept running into advanced use cases where the resulting syntax is somewhat ugly.

Consider a case where most users only send commands, but some experts may want to send commands, gains, and set led colors (for e.g. synchronization of a high-speed camera with logged feedback) in the same message. Using fixed argument calls we could approach this in a few ways:

* Send each in a separate message. Easy, but users can't be sure that all of them arrive at the same time (or at all depending on the protocol).

[source,matlab]
----
sendCommand(cmd);
sendLed(led);
sendGains(gains);
----


* Have multiple calls and combine them into a transaction. More complicated API for 90% use case.

[source,matlab]
----
startMessage();
addCommand(cmd);
addLed(led);
addGains(led);
sendMessage();
----

* Implement both ways and let the user choose. Works, but he API becomes inconsistent between novices and advanced users.

* Keep fixed positions and add dummy arguments that get ignored internally. Confusing which argument is at what position. 

[source,matlab]
----
sendMessage([], [], gains);
----

* Use a single struct with all available commands. Looks overwhelming (>60 fields) and messes with autocomplete (cases like 'position' vs 'positionGainKp'). May interfere with serialization.

At the end of the day, none of these options is particularly great and interfaces well with MATLAB. After several tests and looking throguh many of the built-in methods, we found that the least confusing and most MATLAB-style way to do this is to use parameters, e.g., 

[source,matlab]
----
% simple
sendMessage(cmd);

% advanced
sendMessage(cmd, 'led', led, 'gains', gains);
----

This way the syntax matches built-in functions such as _plot_ and remains consistent for all user levels. The string parameters also helps in understanding code without having to consult the documentation at every step.

[source,]
----
plot(x,y);
plot(x,y,'--rs');
plot(x,y,'--rs', ...
    'LineWidth',2,...
    'MarkerEdgeColor','k',...
    'MarkerFaceColor','g',...
    'MarkerSize',10)
----

Unfortunately, this does not work with a fixed argument approach and requires dynamic argument parsing and input validation. However, after we switched our APIs to this format we had far fewer requests from confused users and we had people come in and be able to control robots within minutes. Note that implementing dynamic parsing was quite a bit of work and not particularly straight forward.

// We also learned that users often try random inputs and work their way through an API by discovering error messages.



== InputParser

MATLAB's https://www.mathworks.com/help/matlab/ref/inputparser-class.html[inputParser] helps to parse function inputs of the standard format. It supports the different argument types (required, optional, parameter) as well as default values and input validation.

[source,matlab]
----
% set defaults
defaultHeight = 1;
defaultUnits = 'inches';
defaultShape = 'rectangle';
expectedShapes = {'square','rectangle','parallelogram'};

% parse inputs
p = inputParser;
p.addRequired('width',@isnumeric);
p.addOptional('height',defaultHeight,@isnumeric);
p.addParameter('units',defaultUnits);
p.addParameter('shape',defaultShape, @(x) any(validatestring(x,expectedShapes)));

p.parse(varargin{:});
a = p.Results.width .* p.Results.height;
----

We could use this built-in parser for parsing user inputs and then forward the output to a fixed argument call.

[source,matlab]
----
function [out] = myMethod(this, varargin)
    % parse inputs
    p = inputParser;
    % ... setup ...
    p.parse(varargin{:});
    r = p.Results;
    out = myMethod(this.javaObj, r.width, r. height, r.units, r.shape);
end
----

This works well for some cases, but we also ran into some limitations with this approach. Some of them were

* Automated end-to-end tests now have a dependency on MATLAB
* No good way to distinguish between default value and not-set (e.g. empty could be a valid user-set value)
* Validation can become very complicated
* Error messages are not useful for cases with non-trivial validation
* There are methods with >20 parameters, at which point this approach becomes unmaintainable and actually degrades performance.

Thus, we ended up implementing our own input parser equivalent entirely behind the Java barrier.


== Wrapper Classes

Our earlier API versions were actually implemented purely in Java without any MATLAB code at all. While the performance was very good and the resulting code looked identical to native MATLAB code, we ran into fundamental limitations with help documentation, setup steps, and access to destructors. We provided help documentation through a call to a _.help()_ method, but this confused users more than we anticipated. Additionally, having to call a setup script to import the right namespaces, as well as doing manual resource management for some cases were confusing and inconvenient. In general, all elements that did not perfectly fit the standard MATLAB paradigm 

In subsequent versions we created MATLAB wrapper classes that provide help documentation and automatically handle any necessary setup and dependency management. This has greatly simplified initialization and removed the most confusing parts. We now believe that users should not even be aware of the fact that there is another language underneath.

[source,matlab]
----
classdef (Sealed) WrapperClass
    %WrapperClass general documentation

    methods(Access = public)
    
        function this = WrapperClass()
            %WrapperClass short documentation
            import namespace.JavaClass;
            this.javaObj = JavaClass(); % corresponding Java object
        end
        
        function [out] = myMethod(this, varargin)
            %myMethod documentation
            out = myMethod(this.obj, varargin{:}); % forwards calls
        end

    end
    
    properties(Access = private, Hidden = true)
        javaObj % backing implementation
    end
    
end
----

Our wrapping methods typically don't contain any logic and purely forward all calls. Note that the performance hit of this additional method call is completely negligible. This is especially true after the advancements in MATLAB's JIT compiler in 2015b.

== Handling Varargs in Java

In our attempt to replicate this functionality in Java, we immediately faced the first issue. The Java language has an equivalent of MATLAB's _varargin_ called _varargs_, which can accept zero or more arguments of the given type.

[source,Java]
----
public void varargsMethod(Object... args){}
----

Unfortunately MATLAB does not support this correctly and interprets _Object..._ the same as the non-varargs _Object_ and expects exactly one argument. However, the same functionality can still be supported by creating method overloads that gather input arguments.

[source,Java]
----
public final class JavaClass {

    public Object myMethod() {
        return myMethod0();
    }

    public Object myMethod(Object o0) {
        return myMethod0(o0);
    }

    public Object myMethod(Object o0, Object o1) {
        return myMethod0(o0, o1);
    }

    public Object myMethod(Object o0, Object o1, Object o2) {
        return myMethod0(o0, o1, o2);
    }

    public Object myMethod(Object o0, Object o1, Object o2, Object o3) {
        return myMethod0(o0, o1, o2, o3);
    }

    public Object myMethod(Object o0, Object o1, Object o2, Object o3, Object o4) {
        return myMethod0(o0, o1, o2, o3, o4);
    }

    private Object myMethod0(Object... args) {
        // parse arguments and implement functionality
        MyMethodParser p = MyMethodParser.parse(args);
        return args;
    }
    
}
----

Unfortunately, this quickly becomes unmaintainable for large APIs that have many methods where each can have many arguments. As a result we developed annotation processors that can automatically generate most of the boiler plate code necessary for interfacing with MATLAB.

[source,Java]
----
@MatlabMethod(maxArgs = 20)
public Object myMethod0(Object... args){
    // ...
}
----

As of this point we have not open sourced these annotation processors, but we may do so in the future.

////
* We need to support arbitrary number of arguments, but Java's varargs _Object..._ does not work

In Java _Object..._ means zero or more argument of the given type. MATLAB unfortunately interprets this equivalent to _Object_ and expects exactly one argument. We ended up working around this limitation by creating many overloads for every method.
////


== Type Conversions

////

The second issue we encountered was that 

* Parameters are all _Object_, so we loose any type conversion and need to support all possible combinations

The MATLAB-Java interface usually handles type conversion automatically to match the target method. This means that a Java method that expects a double will always see a double, no matter whether the actual input type used to be single or int16. However, if the method accepts _Object_, MATLAB converts to the closest matching data type, e.g., _single_ and _int8_ convert to _float_ and _byte_ respectively. 

////

The most extreme example we've so far encountered was a method to set the led color of our components. The goal was to support all representations of colors that MATLAB users are familiar with, and to allow convenient syntax for setting multiple colors at once.

Thus, for a single module it needs to support the following representations:

* Strings: 'red', 'blue', 'green', ...
* Shorthand: 'r', 'b', 'g', ...
* Array: [1 0 0], [0 1 0], [0 0 1], ...

Additionally, more than one module may be targeted in a single call, so it also needs to support the corresponding vector/matrix versions. MATLAB numbers can be practically any data type, so the parser needs to support all of the following Java types, as well as provide input validation with proper error checks.

[source,]
----
String, String[], 
byte[], short[], int[], long[], float[], double[], 
byte[][], short[][], int[][], long[][], float[][], double[][]
----