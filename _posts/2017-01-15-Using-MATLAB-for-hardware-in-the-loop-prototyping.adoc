= Using MATLAB for hardware-in-the-loop prototyping
:published_at: 2017-01-15
:hp-tags: MATLAB, Java
:imagesdir: ../images

MATLAB(C) is a programming language and environment designed for scientific computing. It is one of the best languages for developing control algorithms and is extremely widespread in the robotics research community. Typically researchers use it to prototype algorithms and ideas that subsequently get implemened in another language like C/C++ in order to be tested on real hardware. 

Unfortunately, this porting step causes substantial delays in the feedback loop between considering ideas and testing them in practice. For example, it may take weeks to realize that a given approach may not be able to deal with real world sensor noise. Additionally, many controls engineers do not have a computer science background, and requiring knowledge of C/C++ can pose a significant barrier.

Having experienced this workflow ourselves for many years, we believe that many labs could significantly speed up their research efforts if the hardware could be controlled directly from MATLAB.

We noticed that over the past few years several groups seem to have identified this as a problem and started to develop hardware interfaces for MATLAB. This post will look at some of the available projects and discuss the approaches that were taken to solve this problem.

Note that this blog post is focused purely on the MATLAB programming language and does not discuss Simulink. http://www.mathworks.com[Mathworks] has spent significant efforts on developing automated code generation from Simulink models that may get rid of  tedious manual translation steps.

== Background

The main limitation when trying to use MATLAB to interface with hardware is that the language is fundamentally single threaded. It has been designed to allow non-programmers to do complex math operations without needing to worry complex concepts like multi-threading and synchronization.

This poses a problem because all communications are forced to happen synchronously in the main thread. For example, if we wanted to run a loop at 100Hz and it took a message ~8ms for a round-trip, the main thread would spend 80% of the available time budget waiting for the response and doing no actual work.

The second hurdle is that while math operations are extremely efficient, it can be slow and tedious to create and parse the binary message formats that the target hardware can understand.

Thus, a lot of time gets spent on the communications side, resulting in almost no time budget for performing the interesting math operations. Pure MATLAB implementations still work for simple applications, e.g., interfacing with an Arduino to blink an LED at ~50Hz, but it is not feasible to control complex robotic systems at reasonable rates.

Fortunately, MATLAB does have the ability to interface with other programming languages such as Java and C++ that allow users to create background threads in order to offload the communications aspect from the main thread.

== Message Passing Systems

In https://en.wikipedia.org/wiki/Message_passing[Message passing] systems components communicate by exchanging messages rather than by calling functions directly. At the core they consist of two parts, a way to exchange messages (e.g. UDP or TCP), and a consistent messaging format. They allow system to be built with components (e.g. processes) that run on different computers, different operating systems, and different programming languages. 

These systems are great for larger research projects as they are very extensible and provide a simple way for prototyping. For example, a new component (e.g. a new walking controller) could be implemented in MATLAB and be integrated seamlessly with the rest of the system. Another common example is that an interface to real hardware can easily be exchanged for an interface to simulated hardware.

The ability to interchange components as well as the robotics community's widespread adoption of message passing systems (ROS, LCM, DDS, etc.) make them a great and relatively easy target for MATLAB bindings.

=== Lightweight Communication and Marshalling (LCM)

https://lcm-proj.github.io/tut_matlab.html[LCM] was developed at http://www.mit.edu/[MIT] in 2006 for their entry to DARPA's Urban Challenge. It was the first framework that we know of that came with official bindings for MATLAB. Its MATLAB interface does not contain any actual MATLAB code and is entirely implemented in Java. The interface consists of 3 parts.

* https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/LCM.java[LCM] provides a way to publish messages and subscribe to channels
* https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/MessageAggregator.java[MessageAggregator] receives messages from a background thread and queues them for MATLAB
* Generated Java messages expose public fields that MATLAB can access, and deal with the binary encoding

All network calls as well as the mesage encoding and decoding happen outside of MATLAB, so the main MATLAB thread can spend most of its time on working with the data. Publishing a message could look as follows.

[source,matlab]
----
% Setup
lc = lcm.lcm.LCM.getSingleton();

% Fill message
msg = types.command();
msg.position = [1 2 3];
msg.velocity = [1 2 3];

% Publish
lc.publish('COMMAND_CHANNEL', cmd);
----

Incoming messages are received by subscribing to a channel and picking up messages from the aggregator's queue. Since Java is limited to a single return argument, the _getNextMessage_ call returns a Java type that contains the received byes as well as the source channel name.

[source,java]
----
public class MessageAggregator implements LCMSubscriber {

    public class Message {
    
        // raw data bytes
        final public byte[] data; 
        
        // channel on which it was received
        final public String channel; 
        
        public Message(String channel_, byte[] data_) {
            data = data_;
            channel = channel_;
        }
    }

    public synchronized Message getNextMessage(long timeout_ms) {
        // ...
    }
    
}
----

It is also important for _getNextMessage_ to have a timeout. Calls that get stuck in Java can cause the UI to become unresponsive and may require users to force close MATLAB without being able to save the workspace. A timeout of zero  immediately returns empty if no messages are available.

Receiving messages could look as shown below.

[source,matlab]
----
% Setup 
lc = lcm.lcm.LCM.getSingleton();
aggregator = lcm.lcm.MessageAggregator();
lc.subscribe('FEEDBACK_CHANNEL', aggregator);

% Listen for messages
timeoutMs = 1000;
while true
    
    % Receive byte representation
    msg = aggregator.getNextMessage(timeoutMs);
    
    % Ignore timeouts
    if length(msg) > 0
    
        % Select message type based on channel name
        if strcmp('FEEDBACK_CHANNEL', char(msg.channel))
    
            % Parse message
            fbk = types.feedback(msg.data);
            
            % Use data
            position = fbk.position;
            velocity = fbk.velocity;
        
        end
    
    end
end
----

Overall, we think that this is a great example of a minimum viable interface that works pretty well in practice.

=== Robot Operating System (ROS)

ROS is by far the most widespread messaging framework in the robotics research community and has been officially supported by Mathworks' https://www.mathworks.com/products/robotics.html[Robotics System Toolbox] since 2014. The MATLAB interface is implemented on top of RosJava. The Simulink code generation aspect leverages ROS C++.

It seems that most of their wrapping logic is implemented in MATLAB code, but they make extensive use of various Java libraries for problems that would be difficult to implement in pure MATLAB, e.g., listing network interfaces or in-memory decompression of images.

Users never see any of the underlying implementation because all of the Java calls are hidden behind MATLAB classes. For example, all of the accessors (get/set) in generated messages modify the state of an underlying Java object. Similarly, all Java exceptions get intercepted and wrapped in a MATLAB exception before being exposed to the user.

[source,matlab]
----
% Wrapping property accessors
classdef WrappedMessage

    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    methods
    
        function name = get.Name(obj)
            %get.Name Get the value for property Name
            name = char(obj.JavaMessage.getName);
        end
        
        function set.Name(obj, name)
            %set.Name Set the value for property Name
            validateattributes(name, {'char'}, {}, 'WrappedMessage', 'Name');
            
            obj.JavaMessage.setName(name);
        end
        
        function out = doSomething(obj)
            try
                out = obj.JavaMessage.doSomething();
            catch javaException
                throw(WrappedException(javaException));
            end
        end
        
    end
end
----

There are several different ways to publish and subscribe to topics. An example of one of the ways to publish is shown below.

[source,matlab]
----
% Setup Publisher
chatpub = rospublisher('/chatter', 'std_msgs/String');

% Fill message
msg = rosmessage(chatpub);
msg.Data = 'Some test string';

% Publish
chatpub.send(msg);
----

There are three different interfaces for receiving messages.

[source,matlab]
----
% Setup Subscriber
laser = rossubscriber('/scan');

% (1) Blocking receive
scan = laser.receive(1); % timeout [s]

% (2) Non-blocking latest message (may not be new)
scan = laser.LatestMessage;

% (3) Callback
callback = @(msg) disp(msg);
subscriber = rossubscriber('/scan', @callback);  
----

It is nice that they offer different options to allow users to program in their preferred style. We found the API to be nicer than LCM's because there is less burden on the user for creating and parsing messages which results in more concise code with little overhead. Each topic needs a separate subscriber, but that is not a big limitation and may actually improve code readability.

However, one of the features we were missing when going through the demo code (we didn't have time to actually use the toolbox, so we may have missed something) was a simple way to do non-blocking calls that allow for ignoring old messages equivalent to LCM's _getNextMessage(0)_. We often found this useful when combining sensor topics with e.g. joystick input that creates events in bursts. We tried to see whether we could emulate the same behavior with an extremely small timeout, but any value below 0.1s always returned an error.

[source,matlab]
----
try
    msg = sub.receive(0.1); % below 0.1s always threw an error
    % ... use message ...
catch ex
    % ignore
end
----

Overall, the ROS support looks quite nice and even includes support for importing rosbags and doing path planning. They pre-bundled a lot of commonly used message types, but also support the use of custom messages. This toolbox proably represents the golden standard of how well a library in another language can be seamlessly integrated with MATLAB.

== Related Work

We noticed that over the past few years several groups seem to have come across the same problem and started developing bindings for MATLAB. When we started 

over the past few years there has been quite a bit of development in this area. When we started to look into interfaces, there were almost no resources available. 

We noticed that there has been quite a bit of development in this area. There were almost no available resources when we started with our first attempts several years ago, but recently it seems that several groups have identified the same problem and started to develop bindings for MATLAB.


== Related Work

When we started working on APIs for MATLAB in ~2011 LCM was the only interface we were aware of. However, it seems that in the past years such APIs have become more popular. Now there are several projects with MATLAB bindings, which can generally be grouped into two categories. Below is a list of the existing APIs that we are aware of.

// Split into fixed robots and modular systems? Maye split Generic Message passing systems, fixed systems (Nao etc.), reconfigurable modular systems

* https://www.mathworks.com/hardware-support/rti-dds.html[DDS]

* Interfaces to message passing frameworks. Usually includes background threading. (Async) Requires external applications to communicate with robot.

** http://gazebosim.org/tutorials?cat=haptix&tut=haptix_matlab[OSRF Haptix], MEX/C interface to http://ignitionrobotics.org/[ignition-transport] (MEX)

** https://lcm-proj.github.io/tut_matlab.html[LCM] (Java)

** https://www.mathworks.com/hardware-support/robot-operating-system.html[ROS Support from Robotics System Toolbox] (Java)

** https://github.com/smcgill3/zeromq-matlab[ZeroMQ] (MEX)

** https://github.com/ragavsathish/RabbitMQ-Matlab-Client[RabbitMQ] (Java)



* Interfaces to the raw communication protocol. Usually relies on main thread for the communication aspect. (Sync)

** http://www.robodk.com/Matlab-API.html[RoboDK] (sort of) very high level commands to their main application

** http://support.robotis.com/en/software/dynamixel_sdk/usb2dynamixel/windows/matlab.htm[Dynamixel API]. Extremely low level down to endian conversions

** https://www.mathworks.com/hardware-support/arduino-matlab.html[Arduino] Support from MATLAB

** https://www.mathworks.com/hardware-support/android-sensor.html[TMW Android Sensor support] not real-time? only logging?

** https://henschel-robotics.ch/hdrive/software/[Henschel Servos] writes xml messages using MATLAB's tcp libraries to a web server embedded on the device



* Other

** http://fileadmin.cs.lth.se/cs/education/MMKN30/Nao/download/Documentation/dev/matlab/index.html[Nao]

** https://sourceforge.net/projects/urbi/?source=typ_redirect[URBI] http://agents.csse.uwa.edu.au/aibosig/resources/downloads/tutorial_liburbiMatlab_0.1.pdf[tutorial] not maintained anymore? (2004 last update?)


Table with features? Name, Async, Language, Performance (?), Protocol (binary/text), Object Oriented?, Comment


// Example1:

Message passing systems don't work very well for prototyping with modular systems. For example, consider a case of kinesthetic control where the feedback of a master robot is used to control a second slave robot. This would require changes to the messages, which always results in significant overhead. Definition need to be changed, messages need to be generated, the receiving process needs to be modified, everything has to be recompiled for the target platform and so on. This overhead is justifiable for static systems that live for a long time, but it is a dealbreaker for modular systems that were constructed and programmed in an hour for a quick YouTube video.

////
When showing syntax for other APIs that show setting of a position command, we can show the MSI demo of 1 limp robot controlling position/velocity on another. Maybe include logging as well.

Performance is actually better than original C++ due to no message passing overhead.

Original implementation required additional process that connects to robot and handles other message type.
////

== Our Experiences

As a side note, the http://biorobotics.ri.cmu.edu/robots/index.php[snake robot project] that we used to work on at http://www.cmu.edu[CMU] was entirely based on LCM. We used the MATLAB bindings extensively, but we eventually hit a point where we needed to deal with many messages coming from many channels. This  significantly increased the parsing overhead and made the resulting code very difficult to maintain. We later built a specialized Java API that hid subscriptions and message conversion internally and exposed more convenient methods to users. The resulting API looked similar to the following.

[source,matlab]
----
% Setup
lcmBridge = org.biorobotics.matlab.LcmBridge();

% Control
while true

    if lcmBridge.hasNewFeedback()
        
        % access feedback
        fbk = lcmBridge.getFeedback();
        headPose = lcmBridge.getHeadPose();
        mocap = lcmBridge.getMocapMarkers();
        joy = lcmBridge.getJoystickState();
        
        % ... do stuff ...
        
        % command robot
        lcmBridge.setAngles(zeros(1,16));
    
    end

end
----

This custom API worked very well for our lab until we started building a much more sophisticated generation of hardware that had many tuning options that users needed to access. Due to the nature of message passing systems, each new sensor or settable option required changes to every level of the stack, including the firmware, the network protocol, the receiving process, the message type, as well as the API layer. It quickly became a maintenance nightmare to go through this many layers and we started writing more sophisticated APIs that communicated with the hardware directly, which eliminated several layers.


// LCM improvements
Note that the call to _msg.data_ likely converts Java's _byte[]_ into an _int8_ vector that gets converted back into a _byte[]_ when calling the Java method. This results in the language barrier being crossed twice unnecessarily, which may be quite expensive for larger messages.
