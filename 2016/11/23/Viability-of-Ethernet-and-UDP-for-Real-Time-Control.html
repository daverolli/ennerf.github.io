<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Viability of Ethernet and UDP for Real-Time Control</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://ennerf.github.io/favicon.ico">

    <script type="text/javascript" src="//ennerf.github.io/themes/ichi/assets/js/vendor/fastclick.js?v=1479922877077"></script>
    <script type="text/javascript" src="//ennerf.github.io/themes/ichi/assets/js/vendor/modernizr.js?v=1479922877077"></script>


    <link rel="stylesheet" type="text/css" href="//ennerf.github.io/themes/ichi/assets/css/normalize.css?v=1479922877077" />
    <link rel="stylesheet" type="text/css" href="//ennerf.github.io/themes/ichi/assets/css/foundation.min.css?v=1479922877077" />
    <!--[if lte IE 8]>
        <link rel="stylesheet" type="text/css" href="//ennerf.github.io/themes/ichi/assets/css/outdatedBrowser.min.css?v=1479922877077">
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="//ennerf.github.io/themes/ichi/assets/fonts/foundation-icons/foundation-icons.css?v=1479922877077" />
    <link rel="stylesheet" type="text/css" href="//ennerf.github.io/themes/ichi/assets/css/styles.css?v=1479922877077" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans:300,700,400|Source+Sans+Pro:300,400,600,700,900,300italic,400italic,600italic,700italic,900italic" />

    <link rel="canonical" href="https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Software for Robots" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Viability of Ethernet and UDP for Real-Time Control" />
    <meta property="og:description" content="Ethernet is the most pervasive communication standard in the world. However, it is often dismissed for robotics applications because of its presumed non-deterministic behavior. In this post, we show that in practice Ethernet can be made to be extremely deterministic and provide a flexible and reliable solution for robot communication." />
    <meta property="og:url" content="https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html" />
    <meta property="article:tag" content="Latency" />
    <meta property="article:tag" content=" Ethernet" />
    <meta property="article:tag" content=" UDP" />
    <meta property="article:tag" content=" real-time control" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Viability of Ethernet and UDP for Real-Time Control" />
    <meta name="twitter:description" content="Ethernet is the most pervasive communication standard in the world. However, it is often dismissed for robotics applications because of its presumed non-deterministic behavior. In this post, we show that in practice Ethernet can be made to be extremely deterministic and provide a flexible and reliable solution for robot communication." />
    <meta name="twitter:url" content="https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html" />
    
    <script type="application/ld+json">
null
    </script>

    <meta name="generator" content="HubPress" />
    <link rel="alternate" type="application/rss+xml" title="Software for Robots" href="https://ennerf.github.io/rss/" />
</head>
<body class="post-template tag-Latency tag-Ethernet tag-UDP tag-real-time-control">

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdate" href="http://outdatedbrowser.com/">Update my browser now</a></p>
</div>

<nav class="top-bar hide-for-large-up" data-topbar style="background: none">
  <ul class="title-area">
    <li class="name">

    </li>
    <li class="home"><a class="fi-home" href="https://ennerf.github.io"></a></li>
    <li class="toggle-topbar"><a href="#" id="trigger-overlay" class="fi-list"></a></li>
  </ul>

<div class="overlay overlay-scale">
    <button type="button" class="overlay-close">Close</button>
    <nav>
        <ul>
            <li><a href="https://ennerf.github.io">Home</a></li>
        </ul>
    </nav>
</div>

</nav>

<div class="row">

<div class="small-16 medium-16 large-4 columns right head-area bgimage" style="background-image: url(https://raw.githubusercontent.com/ennerf/ennerf.github.io/master/images/cover-image.jpg)">

<header class="site-head">
    <div class="vertical">
        <div class="site-head-content inner">
            <ul class="side-nav blog-menu show-for-large-up">
                <li><a class="fi-home" href="https://ennerf.github.io"></a></li>
                <li><a class="fi-torso" href="https://ennerf.github.io/about"></a></li>
                <li><a class="fi-mail" href="https://ennerf.github.io/contact"></a></li>
            </ul>
            <a class="blog-logo" href="https://ennerf.github.io"><img alt="Software for Robots" src="https://raw.githubusercontent.com/ennerf/ennerf.github.io/master/images/cover-image.jpg" alt="Blog Logo" /></a>
            <h1 class="blog-title">Software for Robots</h1>
            <hr>
            <p class="blog-description">Real-Time Control, Networking, Operating Systems, Languages</p>
            <div class="blog-network">
<!--                 <a href="#" class="fi-social-pinterest"></a>
                <a href="#" class="fi-social-linkedin"></a>
                <a href="#" class="fi-social-behance"></a>
                <a href="#" class="fi-social-deviant-art"></a>
                <a href="#" class="fi-social-dribbble"></a>
                <a href="#" class="fi-social-flickr"></a>
                <a href="#" class="fi-social-github"></a>
                <a href="#" class="fi-social-skype"></a>
                <a href="#" class="fi-social-snapchat"></a>
                <a href="#" class="fi-social-steam"></a>
                <a href="#" class="fi-social-xbox"></a>
                <a href="#" class="fi-social-reddit"></a> -->
                  <a href="https://github.com/ennerf" class="fi-social-github"></a>
            </div>
        </div>
    </div>
</header>

</div>


<div class="small-16 medium-16 large-12 columns main-column left">
    

<main class="content" role="main">

    <article class="post tag-Latency tag-Ethernet tag-UDP tag-real-time-control">


            <h1 class="post-title">Viability of Ethernet and UDP for Real-Time Control</h1>

            <span class="post-meta label"><time datetime="2016-11-23">23 Nov 2016</time></span>

            <section class="post-content">
                <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Ethernet is the most pervasive communication standard in the world. However, it is often dismissed for robotics applications because of its presumed non-deterministic behavior. In this post, we show that in practice Ethernet can be made to be extremely deterministic and provide a flexible and reliable solution for robot communication.</p>
</div>
<div class="paragraph">
<p>The network topologies and traffic patterns used to control robotic systems exhibit different characteristics than those studied by traditional networking work that focuses on large, ad-hoc networks.
Below we present results from a number of tests and benchmarks, involving over <strong>100 million transmitted packets</strong>. Over the course of all of our tests <strong>no packets were dropped</strong> or received out of order.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_technical_background">Technical Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the primary concerns that roboticists have when considering technologies for real-time control is the predictability of latency. The worst case latency tends to be more important than the overall throughput, so the possibility of latency spikes and packet loss in a communication standard represent significant red flags.</p>
</div>
<div class="paragraph">
<p>Much of the prevalent hesitance towards using Ethernet for real-time control originated in the early days of networking. Nodes used to communicate over a single shared media that employed a control method with random elements for arbitrating access (<a href="https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection">CSMA/CD</a>). When two Frames collided during a transmission, the senders backed off for random timeouts and attempted to retransmit. After a number of failed attempts, frames could be dropped entirely. By connecting more nodes through <a href="https://en.wikipedia.org/wiki/Ethernet_hub">Hubs</a> the <a href="https://en.wikipedia.org/wiki/Collision_domain">Collision Domain</a> was extended further, resulting in more collisions and less predictable behavior.</p>
</div>
<div class="paragraph">
<p>In a process that started in <a href="https://en.wikipedia.org/wiki/Kalpana_(company)">1990</a>, Hubs have been fully replaced with <a href="https://en.wikipedia.org/wiki/Network_switch">Switches</a> that have dedicated full-duplex (separate lines for transmitting and receiving) connections for each port. This separates segments and isolates collision domains, which eliminates any collisions that were happening on the physical (wire) level. CSMA/CD is still supported for backwards compatibility and half-duplex connections, but it is largely obsolete.</p>
</div>
<div class="paragraph">
<p>Using dedicated lines introduces additional buffering and overhead for forwarding Frames to intended receivers. As of 2016, virtually all Switches implement the <a href="https://en.wikipedia.org/wiki/Store_and_forward">Store-and-Forward</a> switching architecture in which Switches fully receive packets, store them in an internal buffer, and then forward them to the appropriate receiver port. This adds a latency cost that scales linearly with the number of Switches that a packet has to go through.
In the alternative <a href="https://en.wikipedia.org/wiki/Cut-through_switching">Cut-through</a> approach Switches can forward packets immediately after receiving the target address, potentially resulting in lower latency. While this is sometimes used in latency sensitive applications, such as financial trading applications, it generally can&#8217;t be found in consumer grade hardware. It is more difficult to implement, only works well if both ports negotiate the same speed, and requires the receiving port to be idle. The benefits are also less significant on smaller packets due to the requirement to buffer enough data to evaluate the target address.</p>
</div>
<div class="paragraph">
<p>Another problem that many roboticists are often concerned about is  <a href="https://en.wikipedia.org/wiki/Out-of-order_delivery">Out-of-Order Delivery</a>, which means that a sequence of packets coming from a single source may be received in a different order. This is relevant for communicating over the Internet, but generally does not apply to local networks without redundant routes and load balancing. Depending on the driver implementation it can theoretically happen on a local network, but we have yet to observe such a case.</p>
</div>
<div class="paragraph">
<p>There are several competing networking standards that are built on Ethernet and can guarantee enough determinism to be used in industrial automation (<a href="https://en.wikipedia.org/wiki/Industrial_Ethernet">Industrial Ethernet</a>). They achieve this by enforcing tight control over the network layout and by limiting the components that can be connected. However, even cheap consumer grade network equipment can produce very good results if the network is controlled in a similar manner.</p>
</div>
<div class="paragraph">
<p>Note that this is not a new concept. We found several resources that discussed similar findings more than a decade ago, e.g., <a href="http://www.embedded.com/design/connectivity/4023291/Real-Time-Ethernet">Real-Time-Ethernet</a> (2001), <a href="https://www.researchgate.net/publication/4232548_Real-time_performance_measurements_using_UDP_on_Windows_and_Linux">Real-time performance measurements using UDP on Windows and Linux</a> (2005), <a href="http://literature.rockwellautomation.com/idc/groups/literature/documents/wp/enet-wp002_-en-p.pdf">Evaluating Industrial Ethernet</a> (2007), and  <a href="http://www.embedded.com/electronics-blogs/cole-bin/4406659/1/Deterministic-networking&#8212;&#8203;from-niches-to-the-mainstream-">Deterministic Networking: from niches to the mainstream</a> (2013).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_benchmark_setup">Benchmark Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A common way to benchmark networks is to setup two computers and have a sender transmit a message to a receiver that echoes it back. That way the sender can measure the <a href="https://en.wikipedia.org/wiki/Round-trip_delay_time">round-trip time (RTT)</a> and gather statistics of the network. This generally works well, but large operating system stacks and device drivers can potentially add a lot of variation. In an attempt to reduce unwanted jitter, we decided to setup a benchmark using two embedded devices instead.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/io-board.jpg"><img src="https://ennerf.github.io/images/udp/io-board.jpg" alt="io board.jpg" width="100%"></a>
</div>
<div class="title">Figure 1. HEBI Robotics I/O Board</div>
</div>
<div class="paragraph">
<p>Our startup <a href="http://hebirobotics.com/">HEBI Robotics</a> builds a variety of building blocks that enable quick development of custom robotic systems. We mainly focus on actuators, but we&#8217;ve also developed other devices such as the I/O Board shown in the picture above. Each board has 48 pins that serve a variety of functions (analog and digitial I/O, PWM, Encoder input, etc.) that can be accessed remotely via network. We normally use them in conjunction with our actuators to interface with external devices, such as a gripper or pneumatic valve, or to get various sensor input into MATLAB.</p>
</div>
<div class="paragraph">
<p>Each device contains a 168MHz ARM microcontroller (STM32f407) and a 100 Mbit/s network port, so we found them to be very convenient for doing network tests. We selected two I/O Boards to act as the sender and receiver nodes and developed custom firmware in order to isolate the network stack. The resulting firmware was based on <a href="http://www.chibios.org/">ChibiOS 2.6.8</a> and <a href="http://savannah.nongnu.org/projects/lwip/">lwIP 1.4.1</a>. The relevant code pieces can be found <a href="https://gist.github.com/ennerf/36a57d432bcff20a58efcdee10f91bd9">here</a>. The elapsed time was measured using a hardware counter with a resolution of 250ns.</p>
</div>
<div class="paragraph">
<p>Since there was no way to store multiple Gigabytes on these devices, we decided to log data remotely using a UDP service that can receive measurement data and persist to disk (see  <a href="https://gist.github.com/ennerf/0ddc4396d15852d28e4eca4a8a923eb7">code</a>). In order to avoid stalls caused by disk I/O, the main socket handler wrote into a double buffered structure that got persisted by a background thread. The synchronization between the threads was done using a <a href="http://stuff-gil-says.blogspot.com/2014/11/writerreaderphaser-story-about-new.html">WriterReaderPhaser</a>, which is a synchronization primitive that allows readers to flip buffers while keeping writers wait-free. We found this primitive to be very useful for persisting events that are represented by small amounts of data.</p>
</div>
<div class="paragraph">
<p>The step by step flow was as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sender wakes up at a fixed rate, e.g., 100Hz</p>
</li>
<li>
<p>Sender increments sequence number</p>
</li>
<li>
<p>Sender measures time ("transmit timestamp") and sends packet to receiver</p>
</li>
<li>
<p>Receiver echoes packet back to sender</p>
</li>
<li>
<p>Sender receives packet and measures time ("receive timestamp")</p>
</li>
<li>
<p>Sender sends measurement to logging server</p>
</li>
<li>
<p>Logging server receives measurement and persists to disk</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting binary data was loaded into MATLAB&#169; for analysis and visualization. The code for reading the binary file can be found <a href="https://gist.github.com/ennerf/19b48406a066f6e946a0567a1a4de1ed">here</a>.</p>
</div>
<div class="paragraph">
<p>The round-trip time is the difference between the receive and transmit timestamps. We also recorded the sequence number of each packet and the ip address of the receiver node in order to detect packet loss and track ordering.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_udp_datagram_size">UDP Datagram Size</h2>
<div class="sectionbody">
<div class="paragraph">
<p>UDP datagrams include a variety of headers that result in a minimum of 66 bytes of overhead. Additionally, Ethernet Frames have a minimum size of 84 bytes, which makes the minimum payload for a UDP Datagram 18 bytes. The rough structure is shown below. More detailed information can be found at <a href="https://en.wikipedia.org/wiki/Ethernet_frame">Ethernet II</a>,  <a href="https://en.wikipedia.org/wiki/IPv4">Internet Protocol (IPv4)</a>, and <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol (UDP)</a>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/ethernet-ip-udp-header.png"><img src="https://ennerf.github.io/images/udp/ethernet-ip-udp-header.png" alt="ethernet ip udp header.png" width="100%"></a>
</div>
<div class="title">Figure 2. UDP / IPv4 / Ethernet II Frame Structure</div>
</div>
<div class="paragraph">
<p>Although this overhead may seem high for traditional automation applications with small payloads (&lt;10 bytes), it quickly amortizes when communicating with smarter devices. For example, each one of our <a href="http://hebirobotics.com/products/">X-Series</a> actuators contains more than 40 sensors (position, velocity, torque, 3-axis gyroscope, 3-axis accelerometer, several temperature sensors, etc.) that get combined into a single packet that uses between 185 and 215 bytes payload. Typical feedback packets from an I/O Board are even larger and require about 300 bytes. When comparing overhead it is also important to consider the available bandwidth, i.e., sending 100 bytes over Gigabit Ethernet (even over 100 Mbit/s) tends to be faster than sending a single byte using traditional non-Ethernet based alternatives such as RS485 or CAN Bus.</p>
</div>
<div class="paragraph">
<p>For these benchmarks we chose to measure the round-trip time for a payload of 200 bytes. After including all overhead, the actual size on the wire is 266 bytes. The theoretical time it takes to transfer 266 bytes over 100 Mbit/s and 1Gbit/s Ethernet is 20.3us and 2.03us respectively.</p>
</div>
<div class="paragraph">
<p>Note that while the size is representative of a typical actuator feedback packet, the round-trip times in production may be faster because outgoing packets (commands) tend to be significantly smaller than response packets (feedback).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_baseline_single_switch">Baseline - Single Switch</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can establish a baseline of the best-case round-trip time by having the sender and receiver nodes communicate with each other through a single Switch that does not see any external traffic. We did not setup a point-to-point connection without any Switches because the logging server needed to be on the same network and because we rarely see this case in practice.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/setup-baseline.png"><img src="https://ennerf.github.io/images/udp/setup-baseline.png" alt="setup baseline.png" width="100%"></a>
</div>
<div class="title">Figure 3. Baseline setup using single Switch</div>
</div>
<div class="paragraph">
<p>We set the frequency to 100Hz and logged data for ~24 hours. We chose this frequency because it is a common control rate for sending high-level trajectories, and because 10ms is a safe deadline in case there are large outliers. During normal operations we typically used rates between 100-200Hz for updating set targets of controllers that get executed on-board each device (e.g. position/velocity/torque), and rates of up to 1KHz when bypassing local controllers and remotely controlling the output (e.g. PWM). The network would technically support even higher rates, but there are usually other limitations that come in at around 1KHz (e.g. OS scheduler and limited sensor polling rates).</p>
</div>
<div class="paragraph">
<p>First, we looked at the jitter of the underlying embedded real-time operating system (RTOS). The figure below shows the difference between an idealized signal that ticks every 10ms and the measured transmit timestamps. 99% are within the lowest measurement resolution (250ns), and the total observed range is slightly below 6us. Note that this is significantly better than the 150us base jitter range we observed on real-time Linux (see <a href="https://ennerf.github.io/2016/09/20/A-Practical-Look-at-Latency-in-Robotics-The-Importance-of-Metrics-and-Operating-Systems.html">The Importance of Metrics and Operating Systems</a>).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/os-jitter-embedded.png"><img src="https://ennerf.github.io/images/udp/os-jitter-embedded.png" alt="os jitter embedded.png" width="100%"></a>
</div>
<div class="title">Figure 4. OS jitter of ChibiOS 2.6.8 on STM32F407 (24h)</div>
</div>
<div class="paragraph">
<p>The two figures below show the round-trip time for all packets and the corresponding percentile distribution. There were a total of 8.5 million messages. None of them were lost and none of them arrived out of order.</p>
</div>
<div id="img-rtt-24h" class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-baseline.png"><img src="https://ennerf.github.io/images/udp/rtt-baseline.png" alt="rtt baseline.png" width="100%"></a>
</div>
<div class="title">Figure 5. RTT for 200 byte payload (24h)</div>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-baseline-zoomed.png"><img src="https://ennerf.github.io/images/udp/rtt-baseline-zoomed.png" alt="rtt baseline zoomed.png" width="100%"></a>
</div>
<div class="title">Figure 6. Zoomed in view of RTT for 200 byte payload (10min)</div>
</div>
<div class="paragraph">
<p>90% of all packets arrived within 194us and a jitter of less than 1 microsecond. Roughly 80us of this time was spent on the wire, so using chips that support Gigabit (rather than 100Mbit) could lower the round-trip time to ~120us. Above the common case, there were three different periodically reoccuring modes that resulted in additional latency.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mode 1 occurs consistently every ~5.3 minutes and lasts for ~15.01 seconds. During this time it adds up to 4 us latency.</p>
</li>
<li>
<p>Mode 2 occurs exactly once every 5 seconds and is always at 210 us.</p>
</li>
<li>
<p>Mode 3 occurs roughly once an hour and adds linearly increasing latency of up to 150 us to 10 packets.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The zoomed in view of a 10 minute time span highlights Modes 1 and 2. All three modes seemed to be related to actual time and independent of rate and packet count. We were unable to find the root cause of these modes, but after several tests we strongly suspected that all of them were caused by the programmed firmware rather than being tied to the Switch or the actual protocol.</p>
</div>
<div class="paragraph">
<p>Overall this initial data looked very promising for being able to use UDP for many real-time control tasks. With more tuning and a better implementation (e.g. lwip with zero copy and tuned options) it seems likely that the maximum jitter could be reduced to below 6us and maybe even below 1us.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_switching_cost">Switching Cost</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned in the background section, most modern Switches use the 'store-and-forward' approach that requires the Switch to fully receive a packet before forwarding it appropriately. Therefore, the latency cost per switch is the time it takes a packet on the wire plus any switching overhead. The wire time is constant (2.03us or 20.3us for 266 bytes), but the overhead depends on the switch implementation. It can be difficult to find good performance data for specific devices, so depending on your requirements you may need to conduct your own benchmarks if you need to evaluate hardware.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/setup-switching-cost.png"><img src="https://ennerf.github.io/images/udp/setup-switching-cost.png" alt="setup switching cost.png" width="100%"></a>
</div>
<div class="title">Figure 7. Benchmark setup with additional Switch</div>
</div>
<div class="paragraph">
<p>For this benchmark we tested the three following Switches and added them individually to the baseline setup as shown above,</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/KSZ8863MLL_FLL_RLL_DS.pdf">MICREL KSZ8863</a> (embedded in X-Series actuators)</p>
</li>
<li>
<p><a href="http://www.downloads.netgear.com/files/GDC/GS105/GS105_datasheet_04Sept03.pdf">NETGEAR ProSAFE GS105</a></p>
</li>
<li>
<p><a href="https://routerboard.com/RB750Gr2">MikroTik RB750Gr2 (RouterBOARD hEX)</a> (technically a Router, but disabling DHCP makes it act similar to a Switch)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In total there were about 1 million packets. Again, we did not observe any packet loss or out-of-order delivery.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-switch-comparison.png"><img src="https://ennerf.github.io/images/udp/rtt-switch-comparison.png" alt="rtt switch comparison.png" width="100%"></a>
</div>
<div class="title">Figure 8. Comparison of RTT through different Switches (35min)</div>
</div>
<div class="paragraph">
<p>The figure below shows a zoomed view of the time series highlighting the added jitter characteristics. Modes 1 and 3 do not seem to be affected by additional switches. Mode 2 remains constant at 210 us and disappears for higher round-trip times, indicating an issue at the receiving step of the sender.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/comparison-switch-latency.png"><img src="https://ennerf.github.io/images/udp/comparison-switch-latency.png" alt="comparison switch latency.png" width="100%"></a>
</div>
<div class="title">Figure 9. Zoomed in view of Switch comparison (10min)</div>
</div>
<div class="paragraph">
<p>Both KSZ8863 and the RB750Gr2 add a constant switching latency of 2.9 us and 3.6 us in addition to the wire time of 40.6 us and 4.06 us respectively to the RTT. The added jitter seems to be negligible at well below 1us. Surprisingly, the GS105 seems to have problems with this use case, resulting in higher latency and more jitter than the KSZ8863 even though it was connected using Gigabit. More details are in the table below.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Switch</th>
<th class="tableblock halign-left valign-top">Connection</th>
<th class="tableblock halign-left valign-top">90%-ile RTT</th>
<th class="tableblock halign-left valign-top">Overhead (not-on-wire)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Baseline</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>2x 100 MBit/s</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>193.8 us</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>112.6 us</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MICREL KSZ8863</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>100 Mbit/s</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>+43.5 us</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>2.9 us</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>NETGEAR ProSAFE GS105</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>1 Gbit/s</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>+51.0 us</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>47 us</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MikroTik RB750Gr2 (RouterBOARD hEX)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>1 Gbit/s</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>+7.7 us</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>3.6 us</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>According to the <a href="http://www.downloads.netgear.com/files/GDC/GS105/GS105_datasheet_04Sept03.pdf">GS105 spec sheet</a>, the added network latency should be below 10us for 1 Gbit/s and 20us for 100 Mbit/s connections. We did additional tests and the GS105 did seem to perform according to spec when using exclusively 100 Mbit/s or 1 Gbit/s on all ports.</p>
</div>
<div class="paragraph">
<p>We also conducted another baseline test that replaced the GS105 with a RB750Gr2. While we found a consistent improvement of 0.5us, we did not consider this significant enough to rerun all tests.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scaling_to_many_devices">Scaling to Many Devices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far all tests were measuring the round-trip time between a sender node and a single target node. Since real robotic systems can contain many devices, e.g., one per axis or degree of freedom, we also looked at how UDP performs with multiple devices on the same network. In conversations with other roboticists we often found an expectation that there would be significant packet loss if multiple packets were to arrive at a Switch at the same time. The worst case would occur if all devices were connected to a single Switch as shown below.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/setup-bursting.png"><img src="https://ennerf.github.io/images/udp/setup-bursting.png" alt="setup bursting.png" width="100%"></a>
</div>
<div class="title">Figure 10. Multiple devices connected to a single Switch</div>
</div>
<div class="paragraph">
<p>In order to test the actual behavior we setup a test consisting of 40 HEBI Robotics I/O boards that were connected to a single 48-port Ethernet Switch (<a href="http://www.downloads.netgear.com/files/GDC/GS748Tv1/GS748T_ds_03Feb05.pdf">GS748T</a>). All devices were running the same (receiver) firmware as before, so sending a single broadcast message triggered 40 response packets that caused more than 10 KB of total traffic to arrive at the Switch within occasionally less than 250 nanoseconds. These <a href="https://en.wikipedia.org/wiki/Micro-bursting_(networking)">Microbursts</a> were well beyond the sustainable bandwidth of Gigabit Ethernet. The setup shown below was representative of a high degree of freedom system such as a full body humanoid robot without daisy-chaining.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/multiple-boards.jpg"><img src="https://ennerf.github.io/images/udp/multiple-boards.jpg" alt="multiple boards.jpg" width="100%"></a>
</div>
<div class="title">Figure 11. Network test setup with 40 HEBI Robotics I/O Boards</div>
</div>
<div class="paragraph">
<p>We would also like to mention that this setup heavily benefited from two side effects of using a standard Ethernet stack. First, there was no need for any manual addressing because of <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a> and device specific globally unique mac addresses. Second, we were able to re-program the firmware on all 40 devices simultaneously within 3-6 seconds due to the fact that we had a bootloader with TCP/IP support. It would have been very tedious to setup such a system if any step had required manual intervention.</p>
</div>
<div class="paragraph">
<p>Since the combined responses resulted in more load than the sender device was able to easily handle, we exchanged the sender I/O Board with a <a href="http://www.gigabyte.com/products/product-page.aspx?pid=4888#ov">Gigabyte Brix i7-4770R</a> desktop computer running Scientific Linux 6.6 with a real-time kernel. We setup the system as described in <a href="https://ennerf.github.io/2016/09/20/A-Practical-Look-at-Latency-in-Robotics-The-Importance-of-Metrics-and-Operating-Systems.html">The Importance of Metrics and Operating Systems</a> and disabled the firewall.</p>
</div>
<div class="paragraph">
<p>Running the benchmark at 100Hz for ~90 minutes resulted in more than 20 million measurements.</p>
</div>
<div class="paragraph">
<p>Again, we first looked at the jitter of the underlying operating system. The figure below shows the difference between an idealized signal that ticks every 10ms and the measured transmit timestamps. It shows that this setup suffers from more than an order of magnitude more jitter than the embedded RTOS. Note that the corresponding jHiccup control chart looks identical as in the OS blog post.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/os-jitter-linux-rt.png"><img src="https://ennerf.github.io/images/udp/os-jitter-linux-rt.png" alt="os jitter linux rt.png" width="100%"></a>
</div>
<div class="title">Figure 12. Operating system jitter of Scientific Linux 6.6 with MRG Realtime</div>
</div>
<div class="paragraph">
<p>The two figures below show the round-trip time for each measurement. It may be surprising, but there was again no packet loss or re-ordering of packets from any single source.</p>
</div>
<div class="paragraph">
<p>Rather than packets being dropped, what actually happened was that all packets got stored in the internal 1.6 MB buffer of the switch, queued, and forwarded to the target port as fast as possible. Since the sender was connected via Gigabit, the packets arrived roughly every ~2us. The time axis in the chart is based on the transmit timestamp, so each cycle shows up as vertical column in the graphs. We also conducted the same test at 1KHz and found identical results.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-linux-40x-zoomed.png"><img src="https://ennerf.github.io/images/udp/rtt-linux-40x-zoomed.png" alt="rtt linux 40x zoomed.png" width="100%"></a>
</div>
<div class="title">Figure 13. Zoomed in RTT for 40 devices</div>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-linux-40x.png"><img src="https://ennerf.github.io/images/udp/rtt-linux-40x.png" alt="rtt linux 40x.png" width="100%"></a>
</div>
<div class="title">Figure 14. RTT for 40 devices (90 min)</div>
</div>
<div class="paragraph">
<p>However, the amount of latency and jitter turned out to be worse than we anticipated. We expected most columns to start at around ~180us and end at ~280us. While this was sometimes the case, the majority of columns started above 300 us. After some initial research we suspected that this delay was mostly caused by the Linux <a href="https://en.wikipedia.org/wiki/New_API">NAPI</a> using polling mode rather than interrupts, and by using a low-cost network interface paired with suboptimal device drivers. While we expected the OS and driver stack to introduce additional latency and jitter, we were surprised by the order of magnitude.</p>
</div>
<div class="paragraph">
<p>The installed network interface and driver are below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ lspci | grep Ethernet</code></pre>
</div>
</div>
<div class="paragraph">
<p>03:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 0c)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ sudo dmesg | grep "Ethernet driver"</code></pre>
</div>
</div>
<div class="paragraph">
<p>r8169 Gigabit Ethernet driver 2.3LK-NAPI loaded</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even consumer-grade Ethernet networks can exhibit very deterministic performance with regards to latency. In the more than 100 million packets that were sent for this blog post, we did not observe any packet loss or out-of order delivery. Even when communicating with 40 smart devices that represent a total of 1.600 sensors at a rate of 1KHz we found the network to be very reliable. While we still believe that large and dangerous industrial robots should be controlled using specialized industrial networking equipment, we feel that standard UDP is more than sufficient for most robotic applications.</p>
</div>
<div class="paragraph">
<p>We also found that most of the observed latency and jitter were caused by the underlying operating systems and their device drivers. To further illustrate this point we did additional comparisons of the baseline setup with the sender node running on different operating systems. The configurations were as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ChibiOS 2.6.8 with lwIP 1.4.1 on 168 MHz STM32F407</p>
</li>
<li>
<p>Windows 10 on Gigabyte Brix-i7-4470R with Realtek NIC</p>
</li>
<li>
<p>Scientific Linux 6.6 with MRG Realtime on Gigabyte Brix-i7-4470R with Realtek NIC</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The two charts below show the round trip time for each system communicating with a single I/O Board over a single Switch. Note that Linux and Windows were connected to the Switch via Gigabit and should have received datagrams ~40us before the embedded device.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-linux-1x-comparison-10h.png"><img src="https://ennerf.github.io/images/udp/rtt-linux-1x-comparison-10h.png" alt="rtt linux 1x comparison 10h.png" width="100%"></a>
</div>
<div class="title">Figure 15. Baseline RTT comparing RTOS vs RT-Linux vs Windows (10h)</div>
</div>
<div class="imageblock text-center">
<div class="content">
<a class="image" href="https://ennerf.github.io/images/udp/rtt-linux-1x-comparison-10m.png"><img src="https://ennerf.github.io/images/udp/rtt-linux-1x-comparison-10m.png" alt="rtt linux 1x comparison 10m.png" width="100%"></a>
</div>
<div class="title">Figure 16. Zoomed in baseline RTT comparing RTOS vs RT-Linux vs Windows (10min)</div>
</div>
<div class="paragraph">
<p>We realize that there are many more interesting questions that were beyond the scope of this work. We are currently considering the following networking-related topics for future blog posts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Comparison of device drivers and network interfaces from various vendors</p>
</li>
<li>
<p>Performance impact of uncontrolled traffic (e.g. streaming video)</p>
</li>
<li>
<p>Redundant routes and sudden disconnects</p>
</li>
<li>
<p>Controlling through wireless networks</p>
</li>
<li>
<p>Clock drift and time synchronization using IEEE 1588v2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are other topics that you think would be worth covering, please leave a note in the comment section. If you are working for a hardware vendor that specializes in low-latency networking equipment and would be willing to provide samples for evaluation, please contact us through our  <a href="http://hebirobotics.com/contact/">website</a>.</p>
</div>
</div>
</div>
                        <aside class="tags fi-pricetag-multiple">Posted on <a href="https://ennerf.github.io/tag/Latency/">Latency</a>, <a href="https://ennerf.github.io/tag/Ethernet/"> Ethernet</a>, <a href="https://ennerf.github.io/tag/UDP/"> UDP</a>, <a href="https://ennerf.github.io/tag/real-time-control/"> real-time control</a></aside>
            </section>
            <hr>
            <footer class="post-footer">

                <section class="share">
                    <h4>Liked this post ? Share it.</h4>
                    <a class="fi-social-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html"
                        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    </a>
                    <a class="fi-social-twitter" href="https://twitter.com/share?text=Viability%20of%20Ethernet%20and%20UDP%20for%20Real-Time%20Control&amp;url=https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html"
                        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    </a>
                    <a class="fi-social-google-plus" href="https://plus.google.com/share?url=https://ennerf.github.io/2016/11/23/Viability-of-Ethernet-and-UDP-for-Real-Time-Control.html"
                       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    </a>
                </section>

                <section class="author">
                    <header>
                        <span>About the author</span>
                    </header>
                    <section>
                        <h4>Florian Enner</h4>
                        <img src="https://avatars.githubusercontent.com/u/5491587?v&#x3D;3">
                        <span>Pittsburgh, PA</span>
                        <a href="https://ennerf.github.io/">https://ennerf.github.io/</a>
                    </section>
                    <footer>
                         <p>Principal Software Engineer at the Robotics Institute at Carnegie Mellon University and Co-Founder of HEBI Robotics.</p>
                    </footer>
                </section>

        <div class="clearfix"></div>
                    <hr>

            </footer>

        <h3 class="title-disqus"><span class="fi-comments"></span>Discussions</h3>




        <section class="post-comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
          var disqus_shortname = 'ennerf'; // required: replace example with your forum shortname
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </section>


    </article>

</main>

</div>

</div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();
      </script>

    <!--[if lte IE 8]>
        <script type="text/javascript" src="//ennerf.github.io/themes/ichi/assets/js/outdatedBrowser.min.js?v=1479922877077"></script>
    <![endif]-->
    <script type="text/javascript" src="//ennerf.github.io/themes/ichi/assets/js/min/built.js?v=1479922877077"></script>

    <script>
      $(document).foundation();
    </script>

    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-83018359-1', 'auto');
    ga('send', 'pageview');

    </script>
</body>
</html>
