= Using MATLAB for hardware-in-the-loop prototyping #1 : Message Passing Systems
:published_at: 2017-06-20
:hp-tags: MATLAB, ROS, LCM, DDS, ZeroMQ, MEX, Java
:imagesdir: ../images
//:imagesdir: https://github.com/ennerf/ennerf.github.io/raw/master/images/
:source-highlighter: none

++++
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
++++

MATLAB(C) is a programming language and environment designed for scientific computing. It is one of the best languages for developing robot control algorithms and is extremely widespread in the research community. While it is generally thought of as an offline programming language, there are several ways to include hardware in the loop. Since there aren't any guidelines for developing such interfaces, we looked at several different projects and compared the approaches they took. This post focuses on projects that integrate with message passing frameworks such as ROS (Robot Operating System) or LCM (lightweight communication and marshalling).

Prototyping directly on real hardware can significantly speed up development because it reduces the time between considering an idea and getting feedback on whether the algorithm can withstand real world physics. A workflow that requires researchers to port prototype code to another language before being able to test on real hardware can lead to multiple weeks or months being lost in chasing down rabbit holes. Additionally, programming in a language like C++ can pose a significant barrier to controls engineers who often don't have a computer science background.

We noticed that over the past few years several groups seem to have identified this as a problem and started to develop ways to control hardware directly from MATLAB.

== The Need for External Languages

The main limitation when trying to use MATLAB to interface with hardware is that its scripting language is fundamentally single threaded. It has been designed to allow non-programmers to do complex math operations without needing to worry about programming concepts like multi-threading or synchronization.

This poses a problem for real-time control of hardware because all communication is forced to happen synchronously in the main thread. For example, if we were to run a loop at 100Hz and it took a message ~8ms for a round-trip, the main thread would spend 80% of the available time budget waiting for a response without doing any actual work.

A second hurdle is that while MATLAB is very efficient in the execution of math operations, it is not particularly well suited for byte manipulation. This makes it difficult to develop code that can efficiently create and parse binary message formats that the target hardware can understand. Thus, after having the main thread spend its time on waiting for and parsing the incoming data, there may not be any time left for performing interesting math operations.

[.text-center]
.Communications overhead in the main MATLAB thread
image::matlab/comms-single-threaded.png[link="{imagesdir}/matlab/comms-single-threaded.png", width="100%"]

Pure MATLAB implementations can work for simple applications, such as interfacing with an Arduino to gather temperature data or blink an LED, but it is not feasible control complex robotic systems at high rates. Fortunately, MATLAB does have the ability to interface with other programming languages that allow users to create background threads in order to offload the communications aspect from the main thread. This frees MATLAB to focus on the calculations that it has been optimized for.

[.text-center]
.Communications overhead offloaded to other threads
image::matlab/comms-multi-threaded.png[link="{imagesdir}/matlab/comms-multi-threaded.png", width="100%"]

Out of the box MATLAB provides two interfaces to other languages:  https://www.mathworks.com/help/matlab/matlab_external/introducing-mex-files.html[MEX] for calling C++ code, and the https://www.mathworks.com/help/matlab/matlab_external/product-overview.html[Java Interface] for calling Java code. There are some differences between the two, but at the end of the day the choice mostly comes down to personal preference. Both provide enough capabilities for developing sophisticated interfaces and have orders of magnitude better performance than required.  There are additional interfaces to https://www.mathworks.com/help/matlab/calling-external-functions.html[other languages], but those require additional setup steps.

== Message Passing Frameworks

https://en.wikipedia.org/wiki/Message_passing[Message passing] frameworks such as http://www.ros.org/[ROS] and https://lcm-proj.github.io/[LCM] have been widely adopated in the robotics research community. At the core they typically consist of two parts: a way to exchange data between processes (e.g. UDP or TCP), and a defined messaging format for encoding and decoding the data. They allow systems to be built with distributed components (e.g. processes) that run on different computers, different operating systems, and different programming languages.

The resulting systems are very extensible and provide convenient ways for prototyping. For example, a component communicating with a physical robot can be exchanged with a simulator without affecting the rest of the system.

The same principle works for other components as well, e.g., a new walking controller could be implemented in MATLAB and communicate with external processes (e.g. robot comms) through the exchange of messages.

Their flexibility, wide-spread adoption, and support for different languages make them a nice starting point for a MATLAB-hardware interface.

////
In https://en.wikipedia.org/wiki/Message_passing[Message passing] systems components communicate by exchanging messages rather than by calling functions directly. At the core they consist of two parts, a way to exchange messages (e.g. UDP or TCP), and a consistent messaging format. They allow system to be built with components (e.g. processes) that run on different computers, different operating systems, and different programming languages. 

For example, a new component (e.g. a new walking controller) could be implemented in MATLAB and be integrated seamlessly with the rest of the system. Another common example is that an interface to real hardware can easily be exchanged for an interface to simulated hardware.

The ability to interchange components as well as the robotics community's widespread adoption of message passing systems (ROS, LCM, DDS, etc.) make them a great and relatively easy target for MATLAB bindings.

In the systems we looked at we found two general approaches to integrate MATLAB with hardware. The most common way is to setup a distributed system in which the actual hardware communication is done in a separate process, and data is exchanged with MATLAB through a messaging framework such as ROS-messaging. This tends to be relatively hardware agnostic and easier to develop, but it does add additional burden during the setup phase and when evolving interfaces. The alternative approach is to create a standalone implementation that runs entirely within MATLAB.
////

=== Lightweight Communication and Marshalling (LCM)

https://lcm-proj.github.io/tut_matlab.html[LCM] is a message passing framework that was developed at http://www.mit.edu/[MIT] in 2006 for their entry to DARPA's Urban Challenge. In the robotics community it became a popular alternative to ROS and was as far as we know the first messaging framework that supported MATLAB as a core language. We found its implementation to be comparatively simple and would recommend it as a starting point when developing similar interfaces.

The snippet below shows how the MATLAB code for sending a command message could look like. The code creates a struct-like _message_, sets desired values, and publishes it on the appropriate channel.

[source,matlab]
----
%% Sending a command message from MATLAB
% Setup
lc = lcm.lcm.LCM.getSingleton();

% Fill message
cmd = types.command();
cmd.position = [1 2 3];
cmd.velocity = [1 2 3];

% Publish
lc.publish('COMMAND_CHANNEL', cmd);
----

Interestingly, the backing implementation of these bindings was done in pure Java and didn't contain any actual MATLAB code. The exposed interface consisted of two Java classes as well as auto-generated message types.

* The https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/LCM.java[LCM] class provided a way to publish messages and subscribe to channels
* The generated Java messages handled the binary encoding and exposed fields that MATLAB can access
* The https://github.com/lcm-proj/lcm/blob/master/lcm-java/lcm/lcm/MessageAggregator.java[MessageAggregator] class provided a way to receive messages on a background thread and queue to for MATLAB.

Thus, even though the snippet looks similar to MATLAB code, all variables are actually Java objects. For example, the struct-like command message type is a Java object that exposes public fields as shown in the snippet below. Users can access them the same way as fields of a standard MATLAB struct (or class properties) resulting in nice syntax. The types are automatically converted according to the https://mathworks.com/help/matlab/matlab_external/passing-data-to-java-methods.html[type mapping].

[source,java]
----
/**
 * Java class that behaves 'struct-like'
 */
public final class command implements lcm.lcm.LCMEncodable
{
    public double[] position;
    public double[] velocity;
    // etc. ...
}
----

Receiving messages is done by subscribing an _aggregator_ to one or more channels. The aggregator receives messages from a background thread and stores them in a queue that MATLAB can access in a synchronous manner using _aggregator.getNextMessage()_. Each message contains the raw bytes as well as some meta data for selecting an appropriate type for decoding.

[source,matlab]
----
%% Receiving a feedback message in MATLAB
% Setup 
lc = lcm.lcm.LCM.getSingleton();
aggregator = lcm.lcm.MessageAggregator();
lc.subscribe('FEEDBACK_CHANNEL', aggregator);

% Continuously check for new messages
timeoutMs = 1000;
while true
    
    % Receive raw message
    msg = aggregator.getNextMessage(timeoutMs);
    
    % Ignore timeouts
    if ~isempty(msg)
    
        % Select message type based on channel name
        if strcmp('FEEDBACK_CHANNEL', char(msg.channel))
    
            % Decode raw bytes to a usable type
            fbk = types.feedback(msg.data);
            
            % Use data
            position = fbk.position;
            velocity = fbk.velocity;
        
        end
    
    end
end
----

The snippet below shows a simplified version of the backing Java code for the aggregator class. Since Java is limited to a single return argument, the _getNextMessage_ call returns a Java type that contains the received bytes as well as meta data to identify the type, i.e., the source channel name.

[source,java]
----
/**
 * Java class for receiving messages in the background
 */
public class MessageAggregator implements LCMSubscriber {

    public class Message {
    
        // raw data bytes
        final public byte[] data; 
        
        // channel on which it was received
        final public String channel; 
        
        public Message(String channel_, byte[] data_) {
            data = data_;
            channel = channel_;
        }
    }

    public synchronized Message getNextMessage(long timeout_ms) {
    
		if (!messages.isEmpty()) {
		    return messages.removeFirst();
        }

        if (timeout_ms == 0) {
            return null;
        }
        
        // Wait for new message ...
    }
    
}
----

Note that the _getNextMessage_ method expects a user settable timeout argument. In general it is important for blocking Java methods to have a timeout in order to prevent the main thread from getting permanently stuck inside Java. Otherwise this could cause the UI to become unresponsive and users may be forced to close MATLAB without being able to save their workspace. Being in a Java call also prohibits users from aborting the execution (ctrl-c), so timeouts should be reasonably short, i.e., in the low seconds.

Passing in a timeout of zero serves as a non-blocking interface that immediately returns empty if no messages are available. This is often useful for working with multiple aggregators or for integrating asynchronous messages with unknown timing, such as user input.

Overall, we thought that this was a well thought out API and a great example for a minimum viable interface that works well in practice. By receiving messages on a background thread and by moving the encoding and decoding steps to the Java language, the main thread was able to spend most of its time on actually working with the data.

Some minor points for improvement that we found were:

* The decoding step _fbk = types.feedback(msg.data)_ forced two unnecessary translations due to _msg.data_ being a _byte[]_, which automatically gets converted to and from _int8_. This could result in a noticeable performance hit when receiving larger messages (e.g. images) and could be avoided by adding an overload that accepts a non-primitive type that does not get translated, e.g., _fbk = types.feedback(msg)_.
* The Java classes didn't implement https://mathworks.com/help/matlab/matlab_external/save-and-load-java-objects-to-mat-files.html[Serializable], which could become bothersome when trying to save the workspace. 
* We'd prefer to select the decoding type during the subscription step, e.g., _lc.subscribe('FEEDBACK_CHANNEL', aggregator, 'types.feedback')_, rather than requiring users to instantiate the type manually. This cleans up the parsing code a bit and allows for a much less confusing error message if types are missing.



